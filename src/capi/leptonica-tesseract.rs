/* automatically generated by rust-bindgen */

pub const L_tmpnam: u32 = 20;
pub const L_ctermid: u32 = 9;
pub const GPLOT_VERSION_NUMBER: u32 = 1;
pub const JB_TEMPLATE_EXT: &'static [u8; 15usize] = b".templates.png\0";
pub const JB_DATA_EXT: &'static [u8; 6usize] = b".data\0";
pub const SEL_VERSION_NUMBER: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __int32_t = ::std::os::raw::c_int;
pub type __quad_t = ::std::os::raw::c_long;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessResultRenderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessTextRenderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessHOcrRenderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessPDFRenderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessUnlvRenderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessBoxTextRenderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessBaseAPI {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessPageIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessResultIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessMutableIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TessChoiceIterator {
    _unused: [u8; 0],
}
pub const TessOcrEngineMode_OEM_TESSERACT_ONLY: TessOcrEngineMode = 0;
pub const TessOcrEngineMode_OEM_LSTM_ONLY: TessOcrEngineMode = 1;
pub const TessOcrEngineMode_OEM_TESSERACT_LSTM_COMBINED: TessOcrEngineMode = 2;
pub const TessOcrEngineMode_OEM_DEFAULT: TessOcrEngineMode = 3;
pub type TessOcrEngineMode = u32;
pub const TessPageSegMode_PSM_OSD_ONLY: TessPageSegMode = 0;
pub const TessPageSegMode_PSM_AUTO_OSD: TessPageSegMode = 1;
pub const TessPageSegMode_PSM_AUTO_ONLY: TessPageSegMode = 2;
pub const TessPageSegMode_PSM_AUTO: TessPageSegMode = 3;
pub const TessPageSegMode_PSM_SINGLE_COLUMN: TessPageSegMode = 4;
pub const TessPageSegMode_PSM_SINGLE_BLOCK_VERT_TEXT: TessPageSegMode = 5;
pub const TessPageSegMode_PSM_SINGLE_BLOCK: TessPageSegMode = 6;
pub const TessPageSegMode_PSM_SINGLE_LINE: TessPageSegMode = 7;
pub const TessPageSegMode_PSM_SINGLE_WORD: TessPageSegMode = 8;
pub const TessPageSegMode_PSM_CIRCLE_WORD: TessPageSegMode = 9;
pub const TessPageSegMode_PSM_SINGLE_CHAR: TessPageSegMode = 10;
pub const TessPageSegMode_PSM_SPARSE_TEXT: TessPageSegMode = 11;
pub const TessPageSegMode_PSM_SPARSE_TEXT_OSD: TessPageSegMode = 12;
pub const TessPageSegMode_PSM_COUNT: TessPageSegMode = 13;
pub type TessPageSegMode = u32;
pub const TessPageIteratorLevel_RIL_BLOCK: TessPageIteratorLevel = 0;
pub const TessPageIteratorLevel_RIL_PARA: TessPageIteratorLevel = 1;
pub const TessPageIteratorLevel_RIL_TEXTLINE: TessPageIteratorLevel = 2;
pub const TessPageIteratorLevel_RIL_WORD: TessPageIteratorLevel = 3;
pub const TessPageIteratorLevel_RIL_SYMBOL: TessPageIteratorLevel = 4;
pub type TessPageIteratorLevel = u32;
pub const TessPolyBlockType_PT_UNKNOWN: TessPolyBlockType = 0;
pub const TessPolyBlockType_PT_FLOWING_TEXT: TessPolyBlockType = 1;
pub const TessPolyBlockType_PT_HEADING_TEXT: TessPolyBlockType = 2;
pub const TessPolyBlockType_PT_PULLOUT_TEXT: TessPolyBlockType = 3;
pub const TessPolyBlockType_PT_EQUATION: TessPolyBlockType = 4;
pub const TessPolyBlockType_PT_INLINE_EQUATION: TessPolyBlockType = 5;
pub const TessPolyBlockType_PT_TABLE: TessPolyBlockType = 6;
pub const TessPolyBlockType_PT_VERTICAL_TEXT: TessPolyBlockType = 7;
pub const TessPolyBlockType_PT_CAPTION_TEXT: TessPolyBlockType = 8;
pub const TessPolyBlockType_PT_FLOWING_IMAGE: TessPolyBlockType = 9;
pub const TessPolyBlockType_PT_HEADING_IMAGE: TessPolyBlockType = 10;
pub const TessPolyBlockType_PT_PULLOUT_IMAGE: TessPolyBlockType = 11;
pub const TessPolyBlockType_PT_HORZ_LINE: TessPolyBlockType = 12;
pub const TessPolyBlockType_PT_VERT_LINE: TessPolyBlockType = 13;
pub const TessPolyBlockType_PT_NOISE: TessPolyBlockType = 14;
pub const TessPolyBlockType_PT_COUNT: TessPolyBlockType = 15;
pub type TessPolyBlockType = u32;
pub const TessOrientation_ORIENTATION_PAGE_UP: TessOrientation = 0;
pub const TessOrientation_ORIENTATION_PAGE_RIGHT: TessOrientation = 1;
pub const TessOrientation_ORIENTATION_PAGE_DOWN: TessOrientation = 2;
pub const TessOrientation_ORIENTATION_PAGE_LEFT: TessOrientation = 3;
pub type TessOrientation = u32;
pub const TessParagraphJustification_JUSTIFICATION_UNKNOWN: TessParagraphJustification = 0;
pub const TessParagraphJustification_JUSTIFICATION_LEFT: TessParagraphJustification = 1;
pub const TessParagraphJustification_JUSTIFICATION_CENTER: TessParagraphJustification = 2;
pub const TessParagraphJustification_JUSTIFICATION_RIGHT: TessParagraphJustification = 3;
pub type TessParagraphJustification = u32;
pub const TessWritingDirection_WRITING_DIRECTION_LEFT_TO_RIGHT: TessWritingDirection = 0;
pub const TessWritingDirection_WRITING_DIRECTION_RIGHT_TO_LEFT: TessWritingDirection = 1;
pub const TessWritingDirection_WRITING_DIRECTION_TOP_TO_BOTTOM: TessWritingDirection = 2;
pub type TessWritingDirection = u32;
pub const TessTextlineOrder_TEXTLINE_ORDER_LEFT_TO_RIGHT: TessTextlineOrder = 0;
pub const TessTextlineOrder_TEXTLINE_ORDER_RIGHT_TO_LEFT: TessTextlineOrder = 1;
pub const TessTextlineOrder_TEXTLINE_ORDER_TOP_TO_BOTTOM: TessTextlineOrder = 2;
pub type TessTextlineOrder = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETEXT_DESC {
    _unused: [u8; 0],
}
extern "C" {
    pub fn TessVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessDeleteText(text: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn TessDeleteTextArray(arr: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn TessDeleteIntArray(arr: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn TessTextRendererCreate(
        outputbase: *const ::std::os::raw::c_char,
    ) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessHOcrRendererCreate(
        outputbase: *const ::std::os::raw::c_char,
    ) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessHOcrRendererCreate2(
        outputbase: *const ::std::os::raw::c_char,
        font_info: ::std::os::raw::c_int,
    ) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessPDFRendererCreate(
        outputbase: *const ::std::os::raw::c_char,
        datadir: *const ::std::os::raw::c_char,
        textonly: ::std::os::raw::c_int,
    ) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessUnlvRendererCreate(
        outputbase: *const ::std::os::raw::c_char,
    ) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessBoxTextRendererCreate(
        outputbase: *const ::std::os::raw::c_char,
    ) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessDeleteResultRenderer(renderer: *mut TessResultRenderer);
}
extern "C" {
    pub fn TessResultRendererInsert(
        renderer: *mut TessResultRenderer,
        next: *mut TessResultRenderer,
    );
}
extern "C" {
    pub fn TessResultRendererNext(renderer: *mut TessResultRenderer) -> *mut TessResultRenderer;
}
extern "C" {
    pub fn TessResultRendererBeginDocument(
        renderer: *mut TessResultRenderer,
        title: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultRendererAddImage(
        renderer: *mut TessResultRenderer,
        api: *mut TessBaseAPI,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultRendererEndDocument(
        renderer: *mut TessResultRenderer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultRendererExtention(
        renderer: *mut TessResultRenderer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessResultRendererTitle(
        renderer: *mut TessResultRenderer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessResultRendererImageNum(renderer: *mut TessResultRenderer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPICreate() -> *mut TessBaseAPI;
}
extern "C" {
    pub fn TessBaseAPIDelete(handle: *mut TessBaseAPI);
}
extern "C" {
    pub fn TessBaseAPIGetOpenCLDevice(
        handle: *mut TessBaseAPI,
        device: *mut *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    pub fn TessBaseAPISetInputName(handle: *mut TessBaseAPI, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn TessBaseAPIGetInputName(handle: *mut TessBaseAPI) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPISetInputImage(handle: *mut TessBaseAPI, pix: *mut Pix);
}
extern "C" {
    pub fn TessBaseAPIGetInputImage(handle: *mut TessBaseAPI) -> *mut Pix;
}
extern "C" {
    pub fn TessBaseAPIGetSourceYResolution(handle: *mut TessBaseAPI) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetDatapath(handle: *mut TessBaseAPI) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPISetOutputName(handle: *mut TessBaseAPI, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn TessBaseAPISetVariable(
        handle: *mut TessBaseAPI,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPISetDebugVariable(
        handle: *mut TessBaseAPI,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetIntVariable(
        handle: *const TessBaseAPI,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetBoolVariable(
        handle: *const TessBaseAPI,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetDoubleVariable(
        handle: *const TessBaseAPI,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetStringVariable(
        handle: *const TessBaseAPI,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIPrintVariables(handle: *const TessBaseAPI, fp: *mut FILE);
}
extern "C" {
    pub fn TessBaseAPIPrintVariablesToFile(
        handle: *const TessBaseAPI,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIInit1(
        handle: *mut TessBaseAPI,
        datapath: *const ::std::os::raw::c_char,
        language: *const ::std::os::raw::c_char,
        oem: TessOcrEngineMode,
        configs: *mut *mut ::std::os::raw::c_char,
        configs_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIInit2(
        handle: *mut TessBaseAPI,
        datapath: *const ::std::os::raw::c_char,
        language: *const ::std::os::raw::c_char,
        oem: TessOcrEngineMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIInit3(
        handle: *mut TessBaseAPI,
        datapath: *const ::std::os::raw::c_char,
        language: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIInit4(
        handle: *mut TessBaseAPI,
        datapath: *const ::std::os::raw::c_char,
        language: *const ::std::os::raw::c_char,
        mode: TessOcrEngineMode,
        configs: *mut *mut ::std::os::raw::c_char,
        configs_size: ::std::os::raw::c_int,
        vars_vec: *mut *mut ::std::os::raw::c_char,
        vars_values: *mut *mut ::std::os::raw::c_char,
        vars_vec_size: usize,
        set_only_non_debug_params: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetInitLanguagesAsString(
        handle: *const TessBaseAPI,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIGetLoadedLanguagesAsVector(
        handle: *const TessBaseAPI,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIGetAvailableLanguagesAsVector(
        handle: *const TessBaseAPI,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIInitLangMod(
        handle: *mut TessBaseAPI,
        datapath: *const ::std::os::raw::c_char,
        language: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIInitForAnalysePage(handle: *mut TessBaseAPI);
}
extern "C" {
    pub fn TessBaseAPIReadConfigFile(
        handle: *mut TessBaseAPI,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn TessBaseAPIReadDebugConfigFile(
        handle: *mut TessBaseAPI,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn TessBaseAPISetPageSegMode(handle: *mut TessBaseAPI, mode: TessPageSegMode);
}
extern "C" {
    pub fn TessBaseAPIGetPageSegMode(handle: *const TessBaseAPI) -> TessPageSegMode;
}
extern "C" {
    pub fn TessBaseAPIRect(
        handle: *mut TessBaseAPI,
        imagedata: *const ::std::os::raw::c_uchar,
        bytes_per_pixel: ::std::os::raw::c_int,
        bytes_per_line: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIClearAdaptiveClassifier(handle: *mut TessBaseAPI);
}
extern "C" {
    pub fn TessBaseAPISetImage(
        handle: *mut TessBaseAPI,
        imagedata: *const ::std::os::raw::c_uchar,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bytes_per_pixel: ::std::os::raw::c_int,
        bytes_per_line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn TessBaseAPISetImage2(handle: *mut TessBaseAPI, pix: *mut Pix);
}
extern "C" {
    pub fn TessBaseAPISetSourceResolution(handle: *mut TessBaseAPI, ppi: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TessBaseAPISetRectangle(
        handle: *mut TessBaseAPI,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn TessBaseAPIGetThresholdedImage(handle: *mut TessBaseAPI) -> *mut Pix;
}
extern "C" {
    pub fn TessBaseAPIGetRegions(handle: *mut TessBaseAPI, pixa: *mut *mut Pixa) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetTextlines(
        handle: *mut TessBaseAPI,
        pixa: *mut *mut Pixa,
        blockids: *mut *mut ::std::os::raw::c_int,
    ) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetTextlines1(
        handle: *mut TessBaseAPI,
        raw_image: ::std::os::raw::c_int,
        raw_padding: ::std::os::raw::c_int,
        pixa: *mut *mut Pixa,
        blockids: *mut *mut ::std::os::raw::c_int,
        paraids: *mut *mut ::std::os::raw::c_int,
    ) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetStrips(
        handle: *mut TessBaseAPI,
        pixa: *mut *mut Pixa,
        blockids: *mut *mut ::std::os::raw::c_int,
    ) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetWords(handle: *mut TessBaseAPI, pixa: *mut *mut Pixa) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetConnectedComponents(
        handle: *mut TessBaseAPI,
        cc: *mut *mut Pixa,
    ) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetComponentImages(
        handle: *mut TessBaseAPI,
        level: TessPageIteratorLevel,
        text_only: ::std::os::raw::c_int,
        pixa: *mut *mut Pixa,
        blockids: *mut *mut ::std::os::raw::c_int,
    ) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetComponentImages1(
        handle: *mut TessBaseAPI,
        level: TessPageIteratorLevel,
        text_only: ::std::os::raw::c_int,
        raw_image: ::std::os::raw::c_int,
        raw_padding: ::std::os::raw::c_int,
        pixa: *mut *mut Pixa,
        blockids: *mut *mut ::std::os::raw::c_int,
        paraids: *mut *mut ::std::os::raw::c_int,
    ) -> *mut Boxa;
}
extern "C" {
    pub fn TessBaseAPIGetThresholdedImageScaleFactor(
        handle: *const TessBaseAPI,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIAnalyseLayout(handle: *mut TessBaseAPI) -> *mut TessPageIterator;
}
extern "C" {
    pub fn TessBaseAPIRecognize(
        handle: *mut TessBaseAPI,
        monitor: *mut ETEXT_DESC,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIRecognizeForChopTest(
        handle: *mut TessBaseAPI,
        monitor: *mut ETEXT_DESC,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIProcessPages(
        handle: *mut TessBaseAPI,
        filename: *const ::std::os::raw::c_char,
        retry_config: *const ::std::os::raw::c_char,
        timeout_millisec: ::std::os::raw::c_int,
        renderer: *mut TessResultRenderer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIProcessPage(
        handle: *mut TessBaseAPI,
        pix: *mut Pix,
        page_index: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        retry_config: *const ::std::os::raw::c_char,
        timeout_millisec: ::std::os::raw::c_int,
        renderer: *mut TessResultRenderer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetIterator(handle: *mut TessBaseAPI) -> *mut TessResultIterator;
}
extern "C" {
    pub fn TessBaseAPIGetMutableIterator(handle: *mut TessBaseAPI) -> *mut TessMutableIterator;
}
extern "C" {
    pub fn TessBaseAPIGetUTF8Text(handle: *mut TessBaseAPI) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIGetHOCRText(
        handle: *mut TessBaseAPI,
        page_number: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIGetBoxText(
        handle: *mut TessBaseAPI,
        page_number: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIGetUNLVText(handle: *mut TessBaseAPI) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPIMeanTextConf(handle: *mut TessBaseAPI) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIAllWordConfidences(handle: *mut TessBaseAPI) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIAdaptToWordStr(
        handle: *mut TessBaseAPI,
        mode: TessPageSegMode,
        wordstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIClear(handle: *mut TessBaseAPI);
}
extern "C" {
    pub fn TessBaseAPIEnd(handle: *mut TessBaseAPI);
}
extern "C" {
    pub fn TessBaseAPIIsValidWord(
        handle: *mut TessBaseAPI,
        word: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetTextDirection(
        handle: *mut TessBaseAPI,
        out_offset: *mut ::std::os::raw::c_int,
        out_slope: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessBaseAPIGetUnichar(
        handle: *mut TessBaseAPI,
        unichar_id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessBaseAPISetMinOrientationMargin(handle: *mut TessBaseAPI, margin: f64);
}
extern "C" {
    pub fn TessPageIteratorDelete(handle: *mut TessPageIterator);
}
extern "C" {
    pub fn TessPageIteratorCopy(handle: *const TessPageIterator) -> *mut TessPageIterator;
}
extern "C" {
    pub fn TessPageIteratorBegin(handle: *mut TessPageIterator);
}
extern "C" {
    pub fn TessPageIteratorNext(
        handle: *mut TessPageIterator,
        level: TessPageIteratorLevel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessPageIteratorIsAtBeginningOf(
        handle: *const TessPageIterator,
        level: TessPageIteratorLevel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessPageIteratorIsAtFinalElement(
        handle: *const TessPageIterator,
        level: TessPageIteratorLevel,
        element: TessPageIteratorLevel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessPageIteratorBoundingBox(
        handle: *const TessPageIterator,
        level: TessPageIteratorLevel,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
        bottom: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessPageIteratorBlockType(handle: *const TessPageIterator) -> TessPolyBlockType;
}
extern "C" {
    pub fn TessPageIteratorGetBinaryImage(
        handle: *const TessPageIterator,
        level: TessPageIteratorLevel,
    ) -> *mut Pix;
}
extern "C" {
    pub fn TessPageIteratorGetImage(
        handle: *const TessPageIterator,
        level: TessPageIteratorLevel,
        padding: ::std::os::raw::c_int,
        original_image: *mut Pix,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
    ) -> *mut Pix;
}
extern "C" {
    pub fn TessPageIteratorBaseline(
        handle: *const TessPageIterator,
        level: TessPageIteratorLevel,
        x1: *mut ::std::os::raw::c_int,
        y1: *mut ::std::os::raw::c_int,
        x2: *mut ::std::os::raw::c_int,
        y2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessPageIteratorOrientation(
        handle: *mut TessPageIterator,
        orientation: *mut TessOrientation,
        writing_direction: *mut TessWritingDirection,
        textline_order: *mut TessTextlineOrder,
        deskew_angle: *mut f32,
    );
}
extern "C" {
    pub fn TessPageIteratorParagraphInfo(
        handle: *mut TessPageIterator,
        justification: *mut TessParagraphJustification,
        is_list_item: *mut ::std::os::raw::c_int,
        is_crown: *mut ::std::os::raw::c_int,
        first_line_indent: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn TessResultIteratorDelete(handle: *mut TessResultIterator);
}
extern "C" {
    pub fn TessResultIteratorCopy(handle: *const TessResultIterator) -> *mut TessResultIterator;
}
extern "C" {
    pub fn TessResultIteratorGetPageIterator(
        handle: *mut TessResultIterator,
    ) -> *mut TessPageIterator;
}
extern "C" {
    pub fn TessResultIteratorGetPageIteratorConst(
        handle: *const TessResultIterator,
    ) -> *const TessPageIterator;
}
extern "C" {
    pub fn TessResultIteratorGetChoiceIterator(
        handle: *const TessResultIterator,
    ) -> *mut TessChoiceIterator;
}
extern "C" {
    pub fn TessResultIteratorNext(
        handle: *mut TessResultIterator,
        level: TessPageIteratorLevel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultIteratorGetUTF8Text(
        handle: *const TessResultIterator,
        level: TessPageIteratorLevel,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessResultIteratorConfidence(
        handle: *const TessResultIterator,
        level: TessPageIteratorLevel,
    ) -> f32;
}
extern "C" {
    pub fn TessResultIteratorWordRecognitionLanguage(
        handle: *const TessResultIterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessResultIteratorWordFontAttributes(
        handle: *const TessResultIterator,
        is_bold: *mut ::std::os::raw::c_int,
        is_italic: *mut ::std::os::raw::c_int,
        is_underlined: *mut ::std::os::raw::c_int,
        is_monospace: *mut ::std::os::raw::c_int,
        is_serif: *mut ::std::os::raw::c_int,
        is_smallcaps: *mut ::std::os::raw::c_int,
        pointsize: *mut ::std::os::raw::c_int,
        font_id: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessResultIteratorWordIsFromDictionary(
        handle: *const TessResultIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultIteratorWordIsNumeric(
        handle: *const TessResultIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultIteratorSymbolIsSuperscript(
        handle: *const TessResultIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultIteratorSymbolIsSubscript(
        handle: *const TessResultIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessResultIteratorSymbolIsDropcap(
        handle: *const TessResultIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessChoiceIteratorDelete(handle: *mut TessChoiceIterator);
}
extern "C" {
    pub fn TessChoiceIteratorNext(handle: *mut TessChoiceIterator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TessChoiceIteratorGetUTF8Text(
        handle: *const TessChoiceIterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TessChoiceIteratorConfidence(handle: *const TessChoiceIterator) -> f32;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type quad_t = __quad_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type l_intptr_t = isize;
pub type l_uintptr_t = usize;
pub type l_int8 = ::std::os::raw::c_schar;
pub type l_uint8 = ::std::os::raw::c_uchar;
pub type l_int16 = ::std::os::raw::c_short;
pub type l_uint16 = ::std::os::raw::c_ushort;
pub type l_int32 = ::std::os::raw::c_int;
pub type l_uint32 = ::std::os::raw::c_uint;
pub type l_float32 = f32;
pub type l_float64 = f64;
pub type l_int64 = ::std::os::raw::c_longlong;
pub type l_uint64 = ::std::os::raw::c_ulonglong;
pub const L_NOT_FOUND: _bindgen_ty_1 = 0;
pub const L_FOUND: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = u32;
pub type L_TIMER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WallTimer {
    pub start_sec: l_int32,
    pub start_usec: l_int32,
    pub stop_sec: l_int32,
    pub stop_usec: l_int32,
}
#[test]
fn bindgen_test_layout_L_WallTimer() {
    assert_eq!(
        ::std::mem::size_of::<L_WallTimer>(),
        16usize,
        concat!("Size of: ", stringify!(L_WallTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WallTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(L_WallTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).start_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).start_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).stop_sec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).stop_usec as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_usec)
        )
    );
}
pub type L_WALLTIMER = L_WallTimer;
pub const L_SEVERITY_EXTERNAL: _bindgen_ty_3 = 0;
pub const L_SEVERITY_ALL: _bindgen_ty_3 = 1;
pub const L_SEVERITY_DEBUG: _bindgen_ty_3 = 2;
pub const L_SEVERITY_INFO: _bindgen_ty_3 = 3;
pub const L_SEVERITY_WARNING: _bindgen_ty_3 = 4;
pub const L_SEVERITY_ERROR: _bindgen_ty_3 = 5;
pub const L_SEVERITY_NONE: _bindgen_ty_3 = 6;
pub type _bindgen_ty_3 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numa {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub refcount: l_int32,
    pub startx: l_float32,
    pub delx: l_float32,
    pub array: *mut l_float32,
}
#[test]
fn bindgen_test_layout_Numa() {
    assert_eq!(
        ::std::mem::size_of::<Numa>(),
        32usize,
        concat!("Size of: ", stringify!(Numa))
    );
    assert_eq!(
        ::std::mem::align_of::<Numa>(),
        8usize,
        concat!("Alignment of ", stringify!(Numa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Numa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).startx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(startx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).delx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(delx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).array as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(array)
        )
    );
}
pub type NUMA = Numa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numaa {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub numa: *mut *mut Numa,
}
#[test]
fn bindgen_test_layout_Numaa() {
    assert_eq!(
        ::std::mem::size_of::<Numaa>(),
        16usize,
        concat!("Size of: ", stringify!(Numaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Numaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Numaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Numaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Numaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).numa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Numaa),
            "::",
            stringify!(numa)
        )
    );
}
pub type NUMAA = Numaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dna {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub refcount: l_int32,
    pub startx: l_float64,
    pub delx: l_float64,
    pub array: *mut l_float64,
}
#[test]
fn bindgen_test_layout_L_Dna() {
    assert_eq!(
        ::std::mem::size_of::<L_Dna>(),
        40usize,
        concat!("Size of: ", stringify!(L_Dna))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dna>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dna))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Dna), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).startx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(startx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).delx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(delx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).array as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(array)
        )
    );
}
pub type L_DNA = L_Dna;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dnaa {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub dna: *mut *mut L_Dna,
}
#[test]
fn bindgen_test_layout_L_Dnaa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dnaa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Dnaa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dnaa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dnaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dnaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Dnaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).dna as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dnaa),
            "::",
            stringify!(dna)
        )
    );
}
pub type L_DNAA = L_Dnaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_DnaHash {
    pub nbuckets: l_int32,
    pub initsize: l_int32,
    pub dna: *mut *mut L_Dna,
}
#[test]
fn bindgen_test_layout_L_DnaHash() {
    assert_eq!(
        ::std::mem::size_of::<L_DnaHash>(),
        16usize,
        concat!("Size of: ", stringify!(L_DnaHash))
    );
    assert_eq!(
        ::std::mem::align_of::<L_DnaHash>(),
        8usize,
        concat!("Alignment of ", stringify!(L_DnaHash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).nbuckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(nbuckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).initsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(initsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).dna as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(dna)
        )
    );
}
pub type L_DNAHASH = L_DnaHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sarray {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub refcount: l_int32,
    pub array: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sarray() {
    assert_eq!(
        ::std::mem::size_of::<Sarray>(),
        24usize,
        concat!("Size of: ", stringify!(Sarray))
    );
    assert_eq!(
        ::std::mem::align_of::<Sarray>(),
        8usize,
        concat!("Alignment of ", stringify!(Sarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sarray), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(array)
        )
    );
}
pub type SARRAY = Sarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bytea {
    pub nalloc: usize,
    pub size: usize,
    pub refcount: l_int32,
    pub data: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_Bytea() {
    assert_eq!(
        ::std::mem::size_of::<L_Bytea>(),
        32usize,
        concat!("Size of: ", stringify!(L_Bytea))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bytea>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bytea))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(data)
        )
    );
}
pub type L_BYTEA = L_Bytea;
pub const L_LINEAR_INTERP: _bindgen_ty_4 = 1;
pub const L_QUADRATIC_INTERP: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = u32;
pub const L_CONTINUED_BORDER: _bindgen_ty_5 = 1;
pub const L_SLOPE_BORDER: _bindgen_ty_5 = 2;
pub const L_MIRRORED_BORDER: _bindgen_ty_5 = 3;
pub type _bindgen_ty_5 = u32;
pub const L_INTEGER_VALUE: _bindgen_ty_6 = 1;
pub const L_FLOAT_VALUE: _bindgen_ty_6 = 2;
pub type _bindgen_ty_6 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_ByteBuffer {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub nwritten: l_int32,
    pub array: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_ByteBuffer() {
    assert_eq!(
        ::std::mem::size_of::<L_ByteBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_ByteBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).nwritten as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nwritten)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(array)
        )
    );
}
pub type L_BBUFFER = L_ByteBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Heap {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub direction: l_int32,
}
#[test]
fn bindgen_test_layout_L_Heap() {
    assert_eq!(
        ::std::mem::size_of::<L_Heap>(),
        24usize,
        concat!("Size of: ", stringify!(L_Heap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Heap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Heap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Heap), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).direction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(direction)
        )
    );
}
pub type L_HEAP = L_Heap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoubleLinkedList {
    pub prev: *mut DoubleLinkedList,
    pub next: *mut DoubleLinkedList,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DoubleLinkedList() {
    assert_eq!(
        ::std::mem::size_of::<DoubleLinkedList>(),
        24usize,
        concat!("Size of: ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        ::std::mem::align_of::<DoubleLinkedList>(),
        8usize,
        concat!("Alignment of ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(data)
        )
    );
}
pub type DLLIST = DoubleLinkedList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptra {
    pub nalloc: l_int32,
    pub imax: l_int32,
    pub nactual: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_L_Ptra() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptra>(),
        24usize,
        concat!("Size of: ", stringify!(L_Ptra))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptra>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptra))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).imax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(imax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).nactual as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nactual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(array)
        )
    );
}
pub type L_PTRA = L_Ptra;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptraa {
    pub nalloc: l_int32,
    pub ptra: *mut *mut L_Ptra,
}
#[test]
fn bindgen_test_layout_L_Ptraa() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptraa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Ptraa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptraa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptraa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptraa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptraa>())).ptra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(ptra)
        )
    );
}
pub type L_PTRAA = L_Ptraa;
pub const L_NO_COMPACTION: _bindgen_ty_7 = 1;
pub const L_COMPACTION: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = u32;
pub const L_AUTO_DOWNSHIFT: _bindgen_ty_8 = 0;
pub const L_MIN_DOWNSHIFT: _bindgen_ty_8 = 1;
pub const L_FULL_DOWNSHIFT: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = u32;
pub const L_HANDLE_ONLY: _bindgen_ty_9 = 0;
pub const L_REMOVE: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Queue {
    pub nalloc: l_int32,
    pub nhead: l_int32,
    pub nelem: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub stack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Queue() {
    assert_eq!(
        ::std::mem::size_of::<L_Queue>(),
        32usize,
        concat!("Size of: ", stringify!(L_Queue))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Queue>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nhead as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nelem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nelem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).stack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(stack)
        )
    );
}
pub type L_QUEUE = L_Queue;
pub const L_INT_TYPE: _bindgen_ty_10 = 1;
pub const L_UINT_TYPE: _bindgen_ty_10 = 2;
pub const L_FLOAT_TYPE: _bindgen_ty_10 = 3;
pub type _bindgen_ty_10 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rb_Type {
    pub itype: l_int64,
    pub utype: l_uint64,
    pub ftype: l_float64,
    pub ptype: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Rb_Type() {
    assert_eq!(
        ::std::mem::size_of::<Rb_Type>(),
        8usize,
        concat!("Size of: ", stringify!(Rb_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<Rb_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(Rb_Type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).itype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).utype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(utype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).ftype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).ptype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ptype)
        )
    );
}
pub type RB_TYPE = Rb_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rbtree {
    pub root: *mut L_Rbtree_Node,
    pub keytype: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree>(),
        16usize,
        concat!("Size of: ", stringify!(L_Rbtree))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree>())).keytype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(keytype)
        )
    );
}
pub type L_RBTREE = L_Rbtree;
pub type L_AMAP = L_Rbtree;
pub type L_ASET = L_Rbtree;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct L_Rbtree_Node {
    pub key: Rb_Type,
    pub value: Rb_Type,
    pub left: *mut L_Rbtree_Node,
    pub right: *mut L_Rbtree_Node,
    pub parent: *mut L_Rbtree_Node,
    pub color: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree_Node() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree_Node>(),
        48usize,
        concat!("Size of: ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree_Node>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).color as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(color)
        )
    );
}
pub type L_RBTREE_NODE = L_Rbtree_Node;
pub type L_AMAP_NODE = L_Rbtree_Node;
pub type L_ASET_NODE = L_Rbtree_Node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Stack {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub auxstack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Stack() {
    assert_eq!(
        ::std::mem::size_of::<L_Stack>(),
        24usize,
        concat!("Size of: ", stringify!(L_Stack))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Stack>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).auxstack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(auxstack)
        )
    );
}
pub type L_STACK = L_Stack;
pub const SPLIT_ON_LEADING_WHITE: _bindgen_ty_11 = 1;
pub const SPLIT_ON_BLANK_LINE: _bindgen_ty_11 = 2;
pub const SPLIT_ON_BOTH: _bindgen_ty_11 = 3;
pub type _bindgen_ty_11 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bmf {
    pub pixa: *mut Pixa,
    pub size: l_int32,
    pub directory: *mut ::std::os::raw::c_char,
    pub baseline1: l_int32,
    pub baseline2: l_int32,
    pub baseline3: l_int32,
    pub lineheight: l_int32,
    pub kernwidth: l_int32,
    pub spacewidth: l_int32,
    pub vertlinesep: l_int32,
    pub fonttab: *mut l_int32,
    pub baselinetab: *mut l_int32,
    pub widthtab: *mut l_int32,
}
#[test]
fn bindgen_test_layout_L_Bmf() {
    assert_eq!(
        ::std::mem::size_of::<L_Bmf>(),
        80usize,
        concat!("Size of: ", stringify!(L_Bmf))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bmf>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bmf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).pixa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).directory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(directory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline3 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).lineheight as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(lineheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).kernwidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(kernwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).spacewidth as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(spacewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).vertlinesep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(vertlinesep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).fonttab as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(fonttab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baselinetab as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baselinetab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).widthtab as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(widthtab)
        )
    );
}
pub type L_BMF = L_Bmf;
pub const CCB_LOCAL_COORDS: _bindgen_ty_12 = 1;
pub const CCB_GLOBAL_COORDS: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = u32;
pub const CCB_SAVE_ALL_PTS: _bindgen_ty_13 = 1;
pub const CCB_SAVE_TURNING_PTS: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBord {
    pub pix: *mut Pix,
    pub boxa: *mut Boxa,
    pub start: *mut Pta,
    pub refcount: l_int32,
    pub local: *mut Ptaa,
    pub global: *mut Ptaa,
    pub step: *mut Numaa,
    pub splocal: *mut Pta,
    pub spglobal: *mut Pta,
}
#[test]
fn bindgen_test_layout_CCBord() {
    assert_eq!(
        ::std::mem::size_of::<CCBord>(),
        72usize,
        concat!("Size of: ", stringify!(CCBord))
    );
    assert_eq!(
        ::std::mem::align_of::<CCBord>(),
        8usize,
        concat!("Alignment of ", stringify!(CCBord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).boxa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).refcount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).local as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).global as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).step as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).splocal as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(splocal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).spglobal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(spglobal)
        )
    );
}
pub type CCBORD = CCBord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBorda {
    pub pix: *mut Pix,
    pub w: l_int32,
    pub h: l_int32,
    pub n: l_int32,
    pub nalloc: l_int32,
    pub ccb: *mut *mut CCBord,
}
#[test]
fn bindgen_test_layout_CCBorda() {
    assert_eq!(
        ::std::mem::size_of::<CCBorda>(),
        32usize,
        concat!("Size of: ", stringify!(CCBorda))
    );
    assert_eq!(
        ::std::mem::align_of::<CCBorda>(),
        8usize,
        concat!("Alignment of ", stringify!(CCBorda))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).nalloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).ccb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(ccb)
        )
    );
}
pub type CCBORDA = CCBorda;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarpa {
    pub nalloc: l_int32,
    pub maxpage: l_int32,
    pub dewarp: *mut *mut L_Dewarp,
    pub dewarpcache: *mut *mut L_Dewarp,
    pub namodels: *mut Numa,
    pub napages: *mut Numa,
    pub redfactor: l_int32,
    pub sampling: l_int32,
    pub minlines: l_int32,
    pub maxdist: l_int32,
    pub max_linecurv: l_int32,
    pub min_diff_linecurv: l_int32,
    pub max_diff_linecurv: l_int32,
    pub max_edgeslope: l_int32,
    pub max_edgecurv: l_int32,
    pub max_diff_edgecurv: l_int32,
    pub useboth: l_int32,
    pub check_columns: l_int32,
    pub modelsready: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarpa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarpa>(),
        96usize,
        concat!("Size of: ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarpa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).maxpage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).dewarp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).dewarpcache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarpcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).namodels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(namodels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).napages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(napages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).redfactor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).sampling as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).minlines as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).maxdist as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxdist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_linecurv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).min_diff_linecurv as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(min_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_diff_linecurv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_edgeslope as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgeslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_edgecurv as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_diff_edgecurv as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_edgecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).useboth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(useboth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).check_columns as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(check_columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).modelsready as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(modelsready)
        )
    );
}
pub type L_DEWARPA = L_Dewarpa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarp {
    pub dewa: *mut L_Dewarpa,
    pub pixs: *mut Pix,
    pub sampvdispar: *mut FPix,
    pub samphdispar: *mut FPix,
    pub sampydispar: *mut FPix,
    pub fullvdispar: *mut FPix,
    pub fullhdispar: *mut FPix,
    pub fullydispar: *mut FPix,
    pub namidys: *mut Numa,
    pub nacurves: *mut Numa,
    pub w: l_int32,
    pub h: l_int32,
    pub pageno: l_int32,
    pub sampling: l_int32,
    pub redfactor: l_int32,
    pub minlines: l_int32,
    pub nlines: l_int32,
    pub mincurv: l_int32,
    pub maxcurv: l_int32,
    pub leftslope: l_int32,
    pub rightslope: l_int32,
    pub leftcurv: l_int32,
    pub rightcurv: l_int32,
    pub nx: l_int32,
    pub ny: l_int32,
    pub hasref: l_int32,
    pub refpage: l_int32,
    pub vsuccess: l_int32,
    pub hsuccess: l_int32,
    pub ysuccess: l_int32,
    pub vvalid: l_int32,
    pub hvalid: l_int32,
    pub skip_horiz: l_int32,
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarp() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarp>(),
        176usize,
        concat!("Size of: ", stringify!(L_Dewarp))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarp>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).dewa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(dewa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).pixs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampvdispar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampvdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).samphdispar as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(samphdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampydispar as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampydispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullvdispar as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullvdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullhdispar as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullhdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullydispar as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullydispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).namidys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(namidys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nacurves as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nacurves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).w as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).h as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).pageno as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pageno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampling as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).redfactor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).minlines as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nlines as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).mincurv as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(mincurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).maxcurv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(maxcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).leftslope as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).rightslope as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).leftcurv as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).rightcurv as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nx as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).ny as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hasref as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hasref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).refpage as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(refpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).vsuccess as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vsuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hsuccess as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hsuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).ysuccess as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ysuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).vvalid as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hvalid as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).skip_horiz as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(skip_horiz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).debug as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(debug)
        )
    );
}
pub type L_DEWARP = L_Dewarp;
pub const GPLOT_STYLE_GPLOT_LINES: GPLOT_STYLE = 0;
pub const GPLOT_STYLE_GPLOT_POINTS: GPLOT_STYLE = 1;
pub const GPLOT_STYLE_GPLOT_IMPULSES: GPLOT_STYLE = 2;
pub const GPLOT_STYLE_GPLOT_LINESPOINTS: GPLOT_STYLE = 3;
pub const GPLOT_STYLE_GPLOT_DOTS: GPLOT_STYLE = 4;
pub type GPLOT_STYLE = u32;
pub const GPLOT_OUTPUT_GPLOT_NONE: GPLOT_OUTPUT = 0;
pub const GPLOT_OUTPUT_GPLOT_PNG: GPLOT_OUTPUT = 1;
pub const GPLOT_OUTPUT_GPLOT_PS: GPLOT_OUTPUT = 2;
pub const GPLOT_OUTPUT_GPLOT_EPS: GPLOT_OUTPUT = 3;
pub const GPLOT_OUTPUT_GPLOT_LATEX: GPLOT_OUTPUT = 4;
pub type GPLOT_OUTPUT = u32;
pub const GPLOT_SCALING_GPLOT_LINEAR_SCALE: GPLOT_SCALING = 0;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X: GPLOT_SCALING = 1;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_Y: GPLOT_SCALING = 2;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X_Y: GPLOT_SCALING = 3;
pub type GPLOT_SCALING = u32;
extern "C" {
    pub static mut gplotstylenames: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut gplotfileoutputs: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPlot {
    pub rootname: *mut ::std::os::raw::c_char,
    pub cmdname: *mut ::std::os::raw::c_char,
    pub cmddata: *mut Sarray,
    pub datanames: *mut Sarray,
    pub plotdata: *mut Sarray,
    pub plottitles: *mut Sarray,
    pub plotstyles: *mut Numa,
    pub nplots: l_int32,
    pub outname: *mut ::std::os::raw::c_char,
    pub outformat: l_int32,
    pub scaling: l_int32,
    pub title: *mut ::std::os::raw::c_char,
    pub xlabel: *mut ::std::os::raw::c_char,
    pub ylabel: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GPlot() {
    assert_eq!(
        ::std::mem::size_of::<GPlot>(),
        104usize,
        concat!("Size of: ", stringify!(GPlot))
    );
    assert_eq!(
        ::std::mem::align_of::<GPlot>(),
        8usize,
        concat!("Alignment of ", stringify!(GPlot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).rootname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(rootname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).cmdname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmdname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).cmddata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmddata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).datanames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(datanames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotdata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plottitles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plottitles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotstyles as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).nplots as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(nplots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).outname as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).outformat as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).scaling as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).title as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).xlabel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(xlabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).ylabel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(ylabel)
        )
    );
}
pub type GPLOT = GPlot;
pub const IFF_UNKNOWN: _bindgen_ty_14 = 0;
pub const IFF_BMP: _bindgen_ty_14 = 1;
pub const IFF_JFIF_JPEG: _bindgen_ty_14 = 2;
pub const IFF_PNG: _bindgen_ty_14 = 3;
pub const IFF_TIFF: _bindgen_ty_14 = 4;
pub const IFF_TIFF_PACKBITS: _bindgen_ty_14 = 5;
pub const IFF_TIFF_RLE: _bindgen_ty_14 = 6;
pub const IFF_TIFF_G3: _bindgen_ty_14 = 7;
pub const IFF_TIFF_G4: _bindgen_ty_14 = 8;
pub const IFF_TIFF_LZW: _bindgen_ty_14 = 9;
pub const IFF_TIFF_ZIP: _bindgen_ty_14 = 10;
pub const IFF_PNM: _bindgen_ty_14 = 11;
pub const IFF_PS: _bindgen_ty_14 = 12;
pub const IFF_GIF: _bindgen_ty_14 = 13;
pub const IFF_JP2: _bindgen_ty_14 = 14;
pub const IFF_WEBP: _bindgen_ty_14 = 15;
pub const IFF_LPDF: _bindgen_ty_14 = 16;
pub const IFF_DEFAULT: _bindgen_ty_14 = 17;
pub const IFF_SPIX: _bindgen_ty_14 = 18;
pub type _bindgen_ty_14 = u32;
pub const L_JPEG_READ_LUMINANCE: _bindgen_ty_16 = 1;
pub const L_JPEG_FAIL_ON_BAD_DATA: _bindgen_ty_16 = 2;
pub type _bindgen_ty_16 = u32;
pub const L_DEFAULT_ENCODE: _bindgen_ty_17 = 0;
pub const L_JPEG_ENCODE: _bindgen_ty_17 = 1;
pub const L_G4_ENCODE: _bindgen_ty_17 = 2;
pub const L_FLATE_ENCODE: _bindgen_ty_17 = 3;
pub const L_JP2K_ENCODE: _bindgen_ty_17 = 4;
pub type _bindgen_ty_17 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Compressed_Data {
    pub type_: l_int32,
    pub datacomp: *mut l_uint8,
    pub nbytescomp: usize,
    pub data85: *mut ::std::os::raw::c_char,
    pub nbytes85: usize,
    pub cmapdata85: *mut ::std::os::raw::c_char,
    pub cmapdatahex: *mut ::std::os::raw::c_char,
    pub ncolors: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub bps: l_int32,
    pub spp: l_int32,
    pub minisblack: l_int32,
    pub predictor: l_int32,
    pub nbytes: usize,
    pub res: l_int32,
}
#[test]
fn bindgen_test_layout_L_Compressed_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Compressed_Data>(),
        104usize,
        concat!("Size of: ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Compressed_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).datacomp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(datacomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytescomp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytescomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).data85 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(data85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytes85 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).cmapdata85 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdata85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).cmapdatahex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdatahex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).ncolors as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).w as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).h as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).bps as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).spp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(spp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).minisblack as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(minisblack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).predictor as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(predictor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).res as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(res)
        )
    );
}
pub type L_COMP_DATA = L_Compressed_Data;
pub const L_FIRST_IMAGE: _bindgen_ty_18 = 1;
pub const L_NEXT_IMAGE: _bindgen_ty_18 = 2;
pub const L_LAST_IMAGE: _bindgen_ty_18 = 3;
pub type _bindgen_ty_18 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Pdf_Data {
    pub title: *mut ::std::os::raw::c_char,
    pub n: l_int32,
    pub ncmap: l_int32,
    pub cida: *mut L_Ptra,
    pub id: *mut ::std::os::raw::c_char,
    pub obj1: *mut ::std::os::raw::c_char,
    pub obj2: *mut ::std::os::raw::c_char,
    pub obj3: *mut ::std::os::raw::c_char,
    pub obj4: *mut ::std::os::raw::c_char,
    pub obj5: *mut ::std::os::raw::c_char,
    pub poststream: *mut ::std::os::raw::c_char,
    pub trailer: *mut ::std::os::raw::c_char,
    pub xy: *mut Pta,
    pub wh: *mut Pta,
    pub mediabox: *mut Box,
    pub saprex: *mut Sarray,
    pub sacmap: *mut Sarray,
    pub objsize: *mut L_Dna,
    pub objloc: *mut L_Dna,
    pub xrefloc: l_int32,
}
#[test]
fn bindgen_test_layout_L_Pdf_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Pdf_Data>(),
        152usize,
        concat!("Size of: ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Pdf_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).ncmap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(ncmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).cida as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(cida)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj4 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj5 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).poststream as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(poststream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).trailer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(trailer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).xy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).wh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(wh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).mediabox as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(mediabox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).saprex as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(saprex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).sacmap as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(sacmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).objsize as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).objloc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).xrefloc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xrefloc)
        )
    );
}
pub type L_PDF_DATA = L_Pdf_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbClasser {
    pub safiles: *mut Sarray,
    pub method: l_int32,
    pub components: l_int32,
    pub maxwidth: l_int32,
    pub maxheight: l_int32,
    pub npages: l_int32,
    pub baseindex: l_int32,
    pub nacomps: *mut Numa,
    pub sizehaus: l_int32,
    pub rankhaus: l_float32,
    pub thresh: l_float32,
    pub weightfactor: l_float32,
    pub naarea: *mut Numa,
    pub w: l_int32,
    pub h: l_int32,
    pub nclass: l_int32,
    pub keep_pixaa: l_int32,
    pub pixaa: *mut Pixaa,
    pub pixat: *mut Pixa,
    pub pixatd: *mut Pixa,
    pub dahash: *mut L_DnaHash,
    pub nafgt: *mut Numa,
    pub ptac: *mut Pta,
    pub ptact: *mut Pta,
    pub naclass: *mut Numa,
    pub napage: *mut Numa,
    pub ptaul: *mut Pta,
    pub ptall: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbClasser() {
    assert_eq!(
        ::std::mem::size_of::<JbClasser>(),
        168usize,
        concat!("Size of: ", stringify!(JbClasser))
    );
    assert_eq!(
        ::std::mem::align_of::<JbClasser>(),
        8usize,
        concat!("Alignment of ", stringify!(JbClasser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).safiles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(safiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).method as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).components as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).maxwidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).maxheight as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).npages as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).baseindex as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(baseindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nacomps as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nacomps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).sizehaus as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(sizehaus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).rankhaus as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(rankhaus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).thresh as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).weightfactor as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(weightfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).naarea as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naarea)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).w as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).h as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nclass as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).keep_pixaa as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(keep_pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixaa as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixatd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixatd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).dahash as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(dahash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nafgt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nafgt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptac as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptact as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).naclass as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).napage as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptaul as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptaul)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptall as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptall)
        )
    );
}
pub type JBCLASSER = JbClasser;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbData {
    pub pix: *mut Pix,
    pub npages: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub nclass: l_int32,
    pub latticew: l_int32,
    pub latticeh: l_int32,
    pub naclass: *mut Numa,
    pub napage: *mut Numa,
    pub ptaul: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbData() {
    assert_eq!(
        ::std::mem::size_of::<JbData>(),
        56usize,
        concat!("Size of: ", stringify!(JbData))
    );
    assert_eq!(
        ::std::mem::align_of::<JbData>(),
        8usize,
        concat!("Alignment of ", stringify!(JbData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).npages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).h as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).nclass as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).latticew as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).latticeh as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticeh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).naclass as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).napage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).ptaul as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(ptaul)
        )
    );
}
pub type JBDATA = JbData;
pub const JB_RANKHAUS: _bindgen_ty_19 = 0;
pub const JB_CORRELATION: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = u32;
pub const JB_CONN_COMPS: _bindgen_ty_20 = 0;
pub const JB_CHARACTERS: _bindgen_ty_20 = 1;
pub const JB_WORDS: _bindgen_ty_20 = 2;
pub type _bindgen_ty_20 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sel {
    pub sy: l_int32,
    pub sx: l_int32,
    pub cy: l_int32,
    pub cx: l_int32,
    pub data: *mut *mut l_int32,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sel() {
    assert_eq!(
        ::std::mem::size_of::<Sel>(),
        32usize,
        concat!("Size of: ", stringify!(Sel))
    );
    assert_eq!(
        ::std::mem::align_of::<Sel>(),
        8usize,
        concat!("Alignment of ", stringify!(Sel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).sy as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).sx as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).cy as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).cx as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).name as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(name))
    );
}
pub type SEL = Sel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sela {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub sel: *mut *mut Sel,
}
#[test]
fn bindgen_test_layout_Sela() {
    assert_eq!(
        ::std::mem::size_of::<Sela>(),
        16usize,
        concat!("Size of: ", stringify!(Sela))
    );
    assert_eq!(
        ::std::mem::align_of::<Sela>(),
        8usize,
        concat!("Alignment of ", stringify!(Sela))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Sela),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).sel as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(sel))
    );
}
pub type SELA = Sela;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Kernel {
    pub sy: l_int32,
    pub sx: l_int32,
    pub cy: l_int32,
    pub cx: l_int32,
    pub data: *mut *mut l_float32,
}
#[test]
fn bindgen_test_layout_L_Kernel() {
    assert_eq!(
        ::std::mem::size_of::<L_Kernel>(),
        24usize,
        concat!("Size of: ", stringify!(L_Kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Kernel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).sy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).sx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).cy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).cx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(data)
        )
    );
}
pub type L_KERNEL = L_Kernel;
pub const SEL_DONT_CARE: _bindgen_ty_22 = 0;
pub const SEL_HIT: _bindgen_ty_22 = 1;
pub const SEL_MISS: _bindgen_ty_22 = 2;
pub type _bindgen_ty_22 = u32;
pub const L_RUN_OFF: _bindgen_ty_23 = 0;
pub const L_RUN_ON: _bindgen_ty_23 = 1;
pub type _bindgen_ty_23 = u32;
pub const L_HORIZ: _bindgen_ty_24 = 1;
pub const L_VERT: _bindgen_ty_24 = 2;
pub const L_BOTH_DIRECTIONS: _bindgen_ty_24 = 3;
pub type _bindgen_ty_24 = u32;
pub const L_MORPH_DILATE: _bindgen_ty_25 = 1;
pub const L_MORPH_ERODE: _bindgen_ty_25 = 2;
pub const L_MORPH_OPEN: _bindgen_ty_25 = 3;
pub const L_MORPH_CLOSE: _bindgen_ty_25 = 4;
pub const L_MORPH_HMT: _bindgen_ty_25 = 5;
pub type _bindgen_ty_25 = u32;
pub const L_LINEAR_SCALE: _bindgen_ty_26 = 1;
pub const L_LOG_SCALE: _bindgen_ty_26 = 2;
pub type _bindgen_ty_26 = u32;
pub const L_TOPHAT_WHITE: _bindgen_ty_27 = 0;
pub const L_TOPHAT_BLACK: _bindgen_ty_27 = 1;
pub type _bindgen_ty_27 = u32;
pub const L_ARITH_ADD: _bindgen_ty_28 = 1;
pub const L_ARITH_SUBTRACT: _bindgen_ty_28 = 2;
pub const L_ARITH_MULTIPLY: _bindgen_ty_28 = 3;
pub const L_ARITH_DIVIDE: _bindgen_ty_28 = 4;
pub const L_UNION: _bindgen_ty_28 = 5;
pub const L_INTERSECTION: _bindgen_ty_28 = 6;
pub const L_SUBTRACTION: _bindgen_ty_28 = 7;
pub const L_EXCLUSIVE_OR: _bindgen_ty_28 = 8;
pub type _bindgen_ty_28 = u32;
pub const L_CHOOSE_MIN: _bindgen_ty_29 = 1;
pub const L_CHOOSE_MAX: _bindgen_ty_29 = 2;
pub const L_CHOOSE_MAXDIFF: _bindgen_ty_29 = 3;
pub const L_CHOOSE_MIN_BOOST: _bindgen_ty_29 = 4;
pub const L_CHOOSE_MAX_BOOST: _bindgen_ty_29 = 5;
pub type _bindgen_ty_29 = u32;
pub const L_BOUNDARY_BG: _bindgen_ty_30 = 1;
pub const L_BOUNDARY_FG: _bindgen_ty_30 = 2;
pub type _bindgen_ty_30 = u32;
pub const L_COMPARE_XOR: _bindgen_ty_31 = 1;
pub const L_COMPARE_SUBTRACT: _bindgen_ty_31 = 2;
pub const L_COMPARE_ABS_DIFF: _bindgen_ty_31 = 3;
pub type _bindgen_ty_31 = u32;
pub const L_MAX_DIFF_FROM_AVERAGE_2: _bindgen_ty_32 = 1;
pub const L_MAX_MIN_DIFF_FROM_2: _bindgen_ty_32 = 2;
pub const L_MAX_DIFF: _bindgen_ty_32 = 3;
pub type _bindgen_ty_32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pix {
    pub w: l_uint32,
    pub h: l_uint32,
    pub d: l_uint32,
    pub spp: l_uint32,
    pub wpl: l_uint32,
    pub refcount: l_uint32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub informat: l_int32,
    pub special: l_int32,
    pub text: *mut ::std::os::raw::c_char,
    pub colormap: *mut PixColormap,
    pub data: *mut l_uint32,
}
#[test]
fn bindgen_test_layout_Pix() {
    assert_eq!(
        ::std::mem::size_of::<Pix>(),
        64usize,
        concat!("Size of: ", stringify!(Pix))
    );
    assert_eq!(
        ::std::mem::align_of::<Pix>(),
        8usize,
        concat!("Alignment of ", stringify!(Pix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).d as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).spp as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(spp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).wpl as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).refcount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).xres as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(xres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).yres as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(yres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).informat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(informat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).special as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(special)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).text as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(text))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).colormap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).data as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(data))
    );
}
pub type PIX = Pix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixColormap {
    pub array: *mut ::std::os::raw::c_void,
    pub depth: l_int32,
    pub nalloc: l_int32,
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_PixColormap() {
    assert_eq!(
        ::std::mem::size_of::<PixColormap>(),
        24usize,
        concat!("Size of: ", stringify!(PixColormap))
    );
    assert_eq!(
        ::std::mem::align_of::<PixColormap>(),
        8usize,
        concat!("Alignment of ", stringify!(PixColormap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).nalloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(n)
        )
    );
}
pub type PIXCMAP = PixColormap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBA_Quad {
    pub blue: l_uint8,
    pub green: l_uint8,
    pub red: l_uint8,
    pub alpha: l_uint8,
}
#[test]
fn bindgen_test_layout_RGBA_Quad() {
    assert_eq!(
        ::std::mem::size_of::<RGBA_Quad>(),
        4usize,
        concat!("Size of: ", stringify!(RGBA_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<RGBA_Quad>(),
        1usize,
        concat!("Alignment of ", stringify!(RGBA_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).blue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).green as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).red as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).alpha as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(alpha)
        )
    );
}
pub type RGBA_QUAD = RGBA_Quad;
pub const COLOR_RED: _bindgen_ty_33 = 0;
pub const COLOR_GREEN: _bindgen_ty_33 = 1;
pub const COLOR_BLUE: _bindgen_ty_33 = 2;
pub const L_ALPHA_CHANNEL: _bindgen_ty_33 = 3;
pub type _bindgen_ty_33 = u32;
pub const L_RED_SHIFT: l_int32 = 24;
pub const L_GREEN_SHIFT: l_int32 = 16;
pub const L_BLUE_SHIFT: l_int32 = 8;
pub const L_ALPHA_SHIFT: l_int32 = 0;
pub const L_DRAW_RED: _bindgen_ty_34 = 0;
pub const L_DRAW_GREEN: _bindgen_ty_34 = 1;
pub const L_DRAW_BLUE: _bindgen_ty_34 = 2;
pub const L_DRAW_SPECIFIED: _bindgen_ty_34 = 3;
pub const L_DRAW_RGB: _bindgen_ty_34 = 4;
pub const L_DRAW_RANDOM: _bindgen_ty_34 = 5;
pub type _bindgen_ty_34 = u32;
pub const L_RED_WEIGHT: l_float32 = 0.30000001192092896;
pub const L_GREEN_WEIGHT: l_float32 = 0.5;
pub const L_BLUE_WEIGHT: l_float32 = 0.20000000298023224;
pub const REMOVE_CMAP_TO_BINARY: _bindgen_ty_35 = 0;
pub const REMOVE_CMAP_TO_GRAYSCALE: _bindgen_ty_35 = 1;
pub const REMOVE_CMAP_TO_FULL_COLOR: _bindgen_ty_35 = 2;
pub const REMOVE_CMAP_WITH_ALPHA: _bindgen_ty_35 = 3;
pub const REMOVE_CMAP_BASED_ON_SRC: _bindgen_ty_35 = 4;
pub type _bindgen_ty_35 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub pix: *mut *mut Pix,
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_Pixa() {
    assert_eq!(
        ::std::mem::size_of::<Pixa>(),
        32usize,
        concat!("Size of: ", stringify!(Pixa))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixa>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).pix as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pixa), "::", stringify!(pix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).boxa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXA = Pixa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixaa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub pixa: *mut *mut Pixa,
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_Pixaa() {
    assert_eq!(
        ::std::mem::size_of::<Pixaa>(),
        24usize,
        concat!("Size of: ", stringify!(Pixaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).pixa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).boxa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXAA = Pixaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Box {
    pub x: l_int32,
    pub y: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub refcount: l_uint32,
}
#[test]
fn bindgen_test_layout_Box() {
    assert_eq!(
        ::std::mem::size_of::<Box>(),
        20usize,
        concat!("Size of: ", stringify!(Box))
    );
    assert_eq!(
        ::std::mem::align_of::<Box>(),
        4usize,
        concat!("Alignment of ", stringify!(Box))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).w as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).h as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Box),
            "::",
            stringify!(refcount)
        )
    );
}
pub type BOX = Box;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub box_: *mut *mut Box,
}
#[test]
fn bindgen_test_layout_Boxa() {
    assert_eq!(
        ::std::mem::size_of::<Boxa>(),
        24usize,
        concat!("Size of: ", stringify!(Boxa))
    );
    assert_eq!(
        ::std::mem::align_of::<Boxa>(),
        8usize,
        concat!("Alignment of ", stringify!(Boxa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Boxa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).box_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(box_)
        )
    );
}
pub type BOXA = Boxa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxaa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub boxa: *mut *mut Boxa,
}
#[test]
fn bindgen_test_layout_Boxaa() {
    assert_eq!(
        ::std::mem::size_of::<Boxaa>(),
        16usize,
        concat!("Size of: ", stringify!(Boxaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Boxaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Boxaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Boxaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).boxa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxaa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type BOXAA = Boxaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pta {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub x: *mut l_float32,
    pub y: *mut l_float32,
}
#[test]
fn bindgen_test_layout_Pta() {
    assert_eq!(
        ::std::mem::size_of::<Pta>(),
        32usize,
        concat!("Size of: ", stringify!(Pta))
    );
    assert_eq!(
        ::std::mem::align_of::<Pta>(),
        8usize,
        concat!("Alignment of ", stringify!(Pta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pta),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pta),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).x as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).y as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(y))
    );
}
pub type PTA = Pta;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ptaa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub pta: *mut *mut Pta,
}
#[test]
fn bindgen_test_layout_Ptaa() {
    assert_eq!(
        ::std::mem::size_of::<Ptaa>(),
        16usize,
        concat!("Size of: ", stringify!(Ptaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Ptaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Ptaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ptaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ptaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).pta as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Ptaa), "::", stringify!(pta))
    );
}
pub type PTAA = Ptaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixacc {
    pub w: l_int32,
    pub h: l_int32,
    pub offset: l_int32,
    pub pix: *mut Pix,
}
#[test]
fn bindgen_test_layout_Pixacc() {
    assert_eq!(
        ::std::mem::size_of::<Pixacc>(),
        24usize,
        concat!("Size of: ", stringify!(Pixacc))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixacc>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixacc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixacc), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pixacc), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixacc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).pix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixacc),
            "::",
            stringify!(pix)
        )
    );
}
pub type PIXACC = Pixacc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixTiling {
    pub pix: *mut Pix,
    pub nx: l_int32,
    pub ny: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub xoverlap: l_int32,
    pub yoverlap: l_int32,
    pub strip: l_int32,
}
#[test]
fn bindgen_test_layout_PixTiling() {
    assert_eq!(
        ::std::mem::size_of::<PixTiling>(),
        40usize,
        concat!("Size of: ", stringify!(PixTiling))
    );
    assert_eq!(
        ::std::mem::align_of::<PixTiling>(),
        8usize,
        concat!("Alignment of ", stringify!(PixTiling))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).nx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).ny as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).xoverlap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(xoverlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).yoverlap as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(yoverlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).strip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(strip)
        )
    );
}
pub type PIXTILING = PixTiling;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPix {
    pub w: l_int32,
    pub h: l_int32,
    pub wpl: l_int32,
    pub refcount: l_uint32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub data: *mut l_float32,
}
#[test]
fn bindgen_test_layout_FPix() {
    assert_eq!(
        ::std::mem::size_of::<FPix>(),
        32usize,
        concat!("Size of: ", stringify!(FPix))
    );
    assert_eq!(
        ::std::mem::align_of::<FPix>(),
        8usize,
        concat!("Alignment of ", stringify!(FPix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).wpl as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).xres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).yres as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(data)
        )
    );
}
pub type FPIX = FPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPixa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub fpix: *mut *mut FPix,
}
#[test]
fn bindgen_test_layout_FPixa() {
    assert_eq!(
        ::std::mem::size_of::<FPixa>(),
        24usize,
        concat!("Size of: ", stringify!(FPixa))
    );
    assert_eq!(
        ::std::mem::align_of::<FPixa>(),
        8usize,
        concat!("Alignment of ", stringify!(FPixa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FPixa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).fpix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(fpix)
        )
    );
}
pub type FPIXA = FPixa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPix {
    pub w: l_int32,
    pub h: l_int32,
    pub wpl: l_int32,
    pub refcount: l_uint32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub data: *mut l_float64,
}
#[test]
fn bindgen_test_layout_DPix() {
    assert_eq!(
        ::std::mem::size_of::<DPix>(),
        32usize,
        concat!("Size of: ", stringify!(DPix))
    );
    assert_eq!(
        ::std::mem::align_of::<DPix>(),
        8usize,
        concat!("Alignment of ", stringify!(DPix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).wpl as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).xres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).yres as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(data)
        )
    );
}
pub type DPIX = DPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixComp {
    pub w: l_int32,
    pub h: l_int32,
    pub d: l_int32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub comptype: l_int32,
    pub text: *mut ::std::os::raw::c_char,
    pub cmapflag: l_int32,
    pub data: *mut l_uint8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_PixComp() {
    assert_eq!(
        ::std::mem::size_of::<PixComp>(),
        56usize,
        concat!("Size of: ", stringify!(PixComp))
    );
    assert_eq!(
        ::std::mem::align_of::<PixComp>(),
        8usize,
        concat!("Alignment of ", stringify!(PixComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).xres as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).yres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).comptype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(comptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).text as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).cmapflag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(cmapflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(size)
        )
    );
}
pub type PIXC = PixComp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixaComp {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub offset: l_int32,
    pub pixc: *mut *mut PixComp,
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_PixaComp() {
    assert_eq!(
        ::std::mem::size_of::<PixaComp>(),
        32usize,
        concat!("Size of: ", stringify!(PixaComp))
    );
    assert_eq!(
        ::std::mem::align_of::<PixaComp>(),
        8usize,
        concat!("Alignment of ", stringify!(PixaComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).pixc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(pixc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).boxa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXAC = PixaComp;
pub const L_NOCOPY: _bindgen_ty_36 = 0;
pub const L_COPY: _bindgen_ty_36 = 1;
pub const L_CLONE: _bindgen_ty_36 = 2;
pub const L_COPY_CLONE: _bindgen_ty_36 = 3;
pub type _bindgen_ty_36 = u32;
pub const L_INSERT: l_int32 = 0;
pub const L_SHELL_SORT: _bindgen_ty_37 = 1;
pub const L_BIN_SORT: _bindgen_ty_37 = 2;
pub type _bindgen_ty_37 = u32;
pub const L_SORT_INCREASING: _bindgen_ty_38 = 1;
pub const L_SORT_DECREASING: _bindgen_ty_38 = 2;
pub type _bindgen_ty_38 = u32;
pub const L_SORT_BY_X: _bindgen_ty_39 = 1;
pub const L_SORT_BY_Y: _bindgen_ty_39 = 2;
pub const L_SORT_BY_RIGHT: _bindgen_ty_39 = 3;
pub const L_SORT_BY_BOT: _bindgen_ty_39 = 4;
pub const L_SORT_BY_WIDTH: _bindgen_ty_39 = 5;
pub const L_SORT_BY_HEIGHT: _bindgen_ty_39 = 6;
pub const L_SORT_BY_MIN_DIMENSION: _bindgen_ty_39 = 7;
pub const L_SORT_BY_MAX_DIMENSION: _bindgen_ty_39 = 8;
pub const L_SORT_BY_PERIMETER: _bindgen_ty_39 = 9;
pub const L_SORT_BY_AREA: _bindgen_ty_39 = 10;
pub const L_SORT_BY_ASPECT_RATIO: _bindgen_ty_39 = 11;
pub type _bindgen_ty_39 = u32;
pub const L_BLEND_WITH_INVERSE: _bindgen_ty_40 = 1;
pub const L_BLEND_TO_WHITE: _bindgen_ty_40 = 2;
pub const L_BLEND_TO_BLACK: _bindgen_ty_40 = 3;
pub const L_BLEND_GRAY: _bindgen_ty_40 = 4;
pub const L_BLEND_GRAY_WITH_INVERSE: _bindgen_ty_40 = 5;
pub type _bindgen_ty_40 = u32;
pub const L_PAINT_LIGHT: _bindgen_ty_41 = 1;
pub const L_PAINT_DARK: _bindgen_ty_41 = 2;
pub type _bindgen_ty_41 = u32;
pub const L_SET_PIXELS: _bindgen_ty_42 = 1;
pub const L_CLEAR_PIXELS: _bindgen_ty_42 = 2;
pub const L_FLIP_PIXELS: _bindgen_ty_42 = 3;
pub type _bindgen_ty_42 = u32;
pub const L_SELECT_WIDTH: _bindgen_ty_43 = 1;
pub const L_SELECT_HEIGHT: _bindgen_ty_43 = 2;
pub const L_SELECT_XVAL: _bindgen_ty_43 = 3;
pub const L_SELECT_YVAL: _bindgen_ty_43 = 4;
pub const L_SELECT_IF_EITHER: _bindgen_ty_43 = 5;
pub const L_SELECT_IF_BOTH: _bindgen_ty_43 = 6;
pub type _bindgen_ty_43 = u32;
pub const L_SELECT_IF_LT: _bindgen_ty_44 = 1;
pub const L_SELECT_IF_GT: _bindgen_ty_44 = 2;
pub const L_SELECT_IF_LTE: _bindgen_ty_44 = 3;
pub const L_SELECT_IF_GTE: _bindgen_ty_44 = 4;
pub type _bindgen_ty_44 = u32;
pub const L_SELECT_RED: _bindgen_ty_45 = 1;
pub const L_SELECT_GREEN: _bindgen_ty_45 = 2;
pub const L_SELECT_BLUE: _bindgen_ty_45 = 3;
pub const L_SELECT_MIN: _bindgen_ty_45 = 4;
pub const L_SELECT_MAX: _bindgen_ty_45 = 5;
pub const L_SELECT_AVERAGE: _bindgen_ty_45 = 6;
pub const L_SELECT_HUE: _bindgen_ty_45 = 7;
pub const L_SELECT_SATURATION: _bindgen_ty_45 = 8;
pub type _bindgen_ty_45 = u32;
pub const L_LS_BYTE: _bindgen_ty_46 = 1;
pub const L_MS_BYTE: _bindgen_ty_46 = 2;
pub const L_AUTO_BYTE: _bindgen_ty_46 = 3;
pub const L_CLIP_TO_FF: _bindgen_ty_46 = 4;
pub const L_LS_TWO_BYTES: _bindgen_ty_46 = 5;
pub const L_MS_TWO_BYTES: _bindgen_ty_46 = 6;
pub const L_CLIP_TO_FFFF: _bindgen_ty_46 = 7;
pub type _bindgen_ty_46 = u32;
pub const L_ROTATE_AREA_MAP: _bindgen_ty_47 = 1;
pub const L_ROTATE_SHEAR: _bindgen_ty_47 = 2;
pub const L_ROTATE_SAMPLING: _bindgen_ty_47 = 3;
pub type _bindgen_ty_47 = u32;
pub const L_BRING_IN_WHITE: _bindgen_ty_48 = 1;
pub const L_BRING_IN_BLACK: _bindgen_ty_48 = 2;
pub type _bindgen_ty_48 = u32;
pub const L_SHEAR_ABOUT_CORNER: _bindgen_ty_49 = 1;
pub const L_SHEAR_ABOUT_CENTER: _bindgen_ty_49 = 2;
pub type _bindgen_ty_49 = u32;
pub const L_TR_SC_RO: _bindgen_ty_50 = 1;
pub const L_SC_RO_TR: _bindgen_ty_50 = 2;
pub const L_RO_TR_SC: _bindgen_ty_50 = 3;
pub const L_TR_RO_SC: _bindgen_ty_50 = 4;
pub const L_RO_SC_TR: _bindgen_ty_50 = 5;
pub const L_SC_TR_RO: _bindgen_ty_50 = 6;
pub type _bindgen_ty_50 = u32;
pub const L_FILL_WHITE: _bindgen_ty_51 = 1;
pub const L_FILL_BLACK: _bindgen_ty_51 = 2;
pub type _bindgen_ty_51 = u32;
pub const L_SET_WHITE: _bindgen_ty_52 = 1;
pub const L_SET_BLACK: _bindgen_ty_52 = 2;
pub type _bindgen_ty_52 = u32;
pub const L_GET_WHITE_VAL: _bindgen_ty_53 = 1;
pub const L_GET_BLACK_VAL: _bindgen_ty_53 = 2;
pub type _bindgen_ty_53 = u32;
pub const L_WHITE_IS_MAX: _bindgen_ty_54 = 1;
pub const L_BLACK_IS_MAX: _bindgen_ty_54 = 2;
pub type _bindgen_ty_54 = u32;
pub const L_MANHATTAN_DISTANCE: _bindgen_ty_56 = 1;
pub const L_EUCLIDEAN_DISTANCE: _bindgen_ty_56 = 2;
pub type _bindgen_ty_56 = u32;
pub const L_NEGATIVE: _bindgen_ty_57 = 1;
pub const L_NON_NEGATIVE: _bindgen_ty_57 = 2;
pub const L_POSITIVE: _bindgen_ty_57 = 3;
pub const L_NON_POSITIVE: _bindgen_ty_57 = 4;
pub const L_ZERO: _bindgen_ty_57 = 5;
pub const L_ALL: _bindgen_ty_57 = 6;
pub type _bindgen_ty_57 = u32;
pub const L_MEAN_ABSVAL: _bindgen_ty_58 = 1;
pub const L_MEDIAN_VAL: _bindgen_ty_58 = 2;
pub const L_MODE_VAL: _bindgen_ty_58 = 3;
pub const L_MODE_COUNT: _bindgen_ty_58 = 4;
pub const L_ROOT_MEAN_SQUARE: _bindgen_ty_58 = 5;
pub const L_STANDARD_DEVIATION: _bindgen_ty_58 = 6;
pub const L_VARIANCE: _bindgen_ty_58 = 7;
pub type _bindgen_ty_58 = u32;
pub const L_CHOOSE_CONSECUTIVE: _bindgen_ty_59 = 1;
pub const L_CHOOSE_SKIP_BY: _bindgen_ty_59 = 2;
pub type _bindgen_ty_59 = u32;
pub const L_TEXT_ORIENT_UNKNOWN: _bindgen_ty_60 = 0;
pub const L_TEXT_ORIENT_UP: _bindgen_ty_60 = 1;
pub const L_TEXT_ORIENT_LEFT: _bindgen_ty_60 = 2;
pub const L_TEXT_ORIENT_DOWN: _bindgen_ty_60 = 3;
pub const L_TEXT_ORIENT_RIGHT: _bindgen_ty_60 = 4;
pub type _bindgen_ty_60 = u32;
pub const L_HORIZONTAL_EDGES: _bindgen_ty_61 = 0;
pub const L_VERTICAL_EDGES: _bindgen_ty_61 = 1;
pub const L_ALL_EDGES: _bindgen_ty_61 = 2;
pub type _bindgen_ty_61 = u32;
pub const L_HORIZONTAL_LINE: _bindgen_ty_62 = 0;
pub const L_POS_SLOPE_LINE: _bindgen_ty_62 = 1;
pub const L_VERTICAL_LINE: _bindgen_ty_62 = 2;
pub const L_NEG_SLOPE_LINE: _bindgen_ty_62 = 3;
pub const L_OBLIQUE_LINE: _bindgen_ty_62 = 4;
pub type _bindgen_ty_62 = u32;
pub const L_PORTRAIT_MODE: _bindgen_ty_63 = 0;
pub const L_LANDSCAPE_MODE: _bindgen_ty_63 = 1;
pub type _bindgen_ty_63 = u32;
pub const L_FROM_LEFT: _bindgen_ty_64 = 0;
pub const L_FROM_RIGHT: _bindgen_ty_64 = 1;
pub const L_FROM_TOP: _bindgen_ty_64 = 2;
pub const L_FROM_BOT: _bindgen_ty_64 = 3;
pub const L_SCAN_NEGATIVE: _bindgen_ty_64 = 4;
pub const L_SCAN_POSITIVE: _bindgen_ty_64 = 5;
pub const L_SCAN_BOTH: _bindgen_ty_64 = 6;
pub const L_SCAN_HORIZONTAL: _bindgen_ty_64 = 7;
pub const L_SCAN_VERTICAL: _bindgen_ty_64 = 8;
pub type _bindgen_ty_64 = u32;
pub const L_ADJUST_SKIP: _bindgen_ty_65 = 0;
pub const L_ADJUST_LEFT: _bindgen_ty_65 = 1;
pub const L_ADJUST_RIGHT: _bindgen_ty_65 = 2;
pub const L_ADJUST_LEFT_AND_RIGHT: _bindgen_ty_65 = 3;
pub const L_ADJUST_TOP: _bindgen_ty_65 = 4;
pub const L_ADJUST_BOT: _bindgen_ty_65 = 5;
pub const L_ADJUST_TOP_AND_BOT: _bindgen_ty_65 = 6;
pub const L_ADJUST_CHOOSE_MIN: _bindgen_ty_65 = 7;
pub const L_ADJUST_CHOOSE_MAX: _bindgen_ty_65 = 8;
pub const L_SET_LEFT: _bindgen_ty_65 = 9;
pub const L_SET_RIGHT: _bindgen_ty_65 = 10;
pub const L_SET_TOP: _bindgen_ty_65 = 11;
pub const L_SET_BOT: _bindgen_ty_65 = 12;
pub const L_GET_LEFT: _bindgen_ty_65 = 13;
pub const L_GET_RIGHT: _bindgen_ty_65 = 14;
pub const L_GET_TOP: _bindgen_ty_65 = 15;
pub const L_GET_BOT: _bindgen_ty_65 = 16;
pub type _bindgen_ty_65 = u32;
pub const L_USE_MINSIZE: _bindgen_ty_66 = 1;
pub const L_USE_MAXSIZE: _bindgen_ty_66 = 2;
pub const L_SUB_ON_LOC_DIFF: _bindgen_ty_66 = 3;
pub const L_SUB_ON_SIZE_DIFF: _bindgen_ty_66 = 4;
pub const L_USE_CAPPED_MIN: _bindgen_ty_66 = 5;
pub const L_USE_CAPPED_MAX: _bindgen_ty_66 = 6;
pub type _bindgen_ty_66 = u32;
pub const L_COMBINE: _bindgen_ty_67 = 1;
pub const L_REMOVE_SMALL: _bindgen_ty_67 = 2;
pub type _bindgen_ty_67 = u32;
pub const L_USE_ALL_BOXES: _bindgen_ty_68 = 1;
pub const L_USE_SAME_PARITY_BOXES: _bindgen_ty_68 = 2;
pub type _bindgen_ty_68 = u32;
pub const L_WARP_TO_LEFT: _bindgen_ty_69 = 1;
pub const L_WARP_TO_RIGHT: _bindgen_ty_69 = 2;
pub type _bindgen_ty_69 = u32;
pub const L_LINEAR_WARP: _bindgen_ty_70 = 1;
pub const L_QUADRATIC_WARP: _bindgen_ty_70 = 2;
pub type _bindgen_ty_70 = u32;
pub const L_INTERPOLATED: _bindgen_ty_71 = 1;
pub const L_SAMPLED: _bindgen_ty_71 = 2;
pub type _bindgen_ty_71 = u32;
pub const L_THIN_FG: _bindgen_ty_72 = 1;
pub const L_THIN_BG: _bindgen_ty_72 = 2;
pub type _bindgen_ty_72 = u32;
pub const L_HORIZONTAL_RUNS: _bindgen_ty_73 = 0;
pub const L_VERTICAL_RUNS: _bindgen_ty_73 = 1;
pub type _bindgen_ty_73 = u32;
pub const L_SOBEL_EDGE: _bindgen_ty_74 = 1;
pub const L_TWO_SIDED_EDGE: _bindgen_ty_74 = 2;
pub type _bindgen_ty_74 = u32;
pub const L_SUBPIXEL_ORDER_RGB: _bindgen_ty_75 = 1;
pub const L_SUBPIXEL_ORDER_BGR: _bindgen_ty_75 = 2;
pub const L_SUBPIXEL_ORDER_VRGB: _bindgen_ty_75 = 3;
pub const L_SUBPIXEL_ORDER_VBGR: _bindgen_ty_75 = 4;
pub type _bindgen_ty_75 = u32;
pub const L_HS_HISTO: _bindgen_ty_76 = 1;
pub const L_HV_HISTO: _bindgen_ty_76 = 2;
pub const L_SV_HISTO: _bindgen_ty_76 = 3;
pub type _bindgen_ty_76 = u32;
pub const L_INCLUDE_REGION: _bindgen_ty_77 = 1;
pub const L_EXCLUDE_REGION: _bindgen_ty_77 = 2;
pub type _bindgen_ty_77 = u32;
pub const L_ADD_ABOVE: _bindgen_ty_78 = 1;
pub const L_ADD_BELOW: _bindgen_ty_78 = 2;
pub const L_ADD_LEFT: _bindgen_ty_78 = 3;
pub const L_ADD_RIGHT: _bindgen_ty_78 = 4;
pub const L_ADD_AT_TOP: _bindgen_ty_78 = 5;
pub const L_ADD_AT_BOT: _bindgen_ty_78 = 6;
pub const L_ADD_AT_LEFT: _bindgen_ty_78 = 7;
pub const L_ADD_AT_RIGHT: _bindgen_ty_78 = 8;
pub type _bindgen_ty_78 = u32;
pub const L_PLOT_AT_TOP: _bindgen_ty_79 = 1;
pub const L_PLOT_AT_MID_HORIZ: _bindgen_ty_79 = 2;
pub const L_PLOT_AT_BOT: _bindgen_ty_79 = 3;
pub const L_PLOT_AT_LEFT: _bindgen_ty_79 = 4;
pub const L_PLOT_AT_MID_VERT: _bindgen_ty_79 = 5;
pub const L_PLOT_AT_RIGHT: _bindgen_ty_79 = 6;
pub type _bindgen_ty_79 = u32;
pub const L_DISPLAY_WITH_XZGV: _bindgen_ty_80 = 1;
pub const L_DISPLAY_WITH_XLI: _bindgen_ty_80 = 2;
pub const L_DISPLAY_WITH_XV: _bindgen_ty_80 = 3;
pub const L_DISPLAY_WITH_IV: _bindgen_ty_80 = 4;
pub const L_DISPLAY_WITH_OPEN: _bindgen_ty_80 = 5;
pub type _bindgen_ty_80 = u32;
pub const L_NO_CHROMA_SAMPLING_JPEG: _bindgen_ty_81 = 1;
pub type _bindgen_ty_81 = u32;
pub const L_CLIP_TO_ZERO: _bindgen_ty_82 = 1;
pub const L_TAKE_ABSVAL: _bindgen_ty_82 = 2;
pub type _bindgen_ty_82 = u32;
pub const L_LESS_THAN_ZERO: _bindgen_ty_83 = 1;
pub const L_EQUAL_TO_ZERO: _bindgen_ty_83 = 2;
pub const L_GREATER_THAN_ZERO: _bindgen_ty_83 = 3;
pub type _bindgen_ty_83 = u32;
pub const L_ADD_TRAIL_SLASH: _bindgen_ty_84 = 1;
pub const L_REMOVE_TRAIL_SLASH: _bindgen_ty_84 = 2;
pub type _bindgen_ty_84 = u32;
pub type alloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>;
pub type dealloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Recog {
    pub scalew: l_int32,
    pub scaleh: l_int32,
    pub linew: l_int32,
    pub templ_use: l_int32,
    pub maxarraysize: l_int32,
    pub setsize: l_int32,
    pub threshold: l_int32,
    pub maxyshift: l_int32,
    pub charset_type: l_int32,
    pub charset_size: l_int32,
    pub min_nopad: l_int32,
    pub num_samples: l_int32,
    pub minwidth_u: l_int32,
    pub maxwidth_u: l_int32,
    pub minheight_u: l_int32,
    pub maxheight_u: l_int32,
    pub minwidth: l_int32,
    pub maxwidth: l_int32,
    pub ave_done: l_int32,
    pub train_done: l_int32,
    pub max_wh_ratio: l_float32,
    pub max_ht_ratio: l_float32,
    pub min_splitw: l_int32,
    pub max_splith: l_int32,
    pub sa_text: *mut Sarray,
    pub dna_tochar: *mut L_Dna,
    pub centtab: *mut l_int32,
    pub sumtab: *mut l_int32,
    pub pixaa_u: *mut Pixaa,
    pub ptaa_u: *mut Ptaa,
    pub naasum_u: *mut Numaa,
    pub pixaa: *mut Pixaa,
    pub ptaa: *mut Ptaa,
    pub naasum: *mut Numaa,
    pub pixa_u: *mut Pixa,
    pub pta_u: *mut Pta,
    pub nasum_u: *mut Numa,
    pub pixa: *mut Pixa,
    pub pta: *mut Pta,
    pub nasum: *mut Numa,
    pub pixa_tr: *mut Pixa,
    pub pixadb_ave: *mut Pixa,
    pub pixa_id: *mut Pixa,
    pub pixdb_ave: *mut Pix,
    pub pixdb_range: *mut Pix,
    pub pixadb_boot: *mut Pixa,
    pub pixadb_split: *mut Pixa,
    pub bmf: *mut L_Bmf,
    pub bmf_size: l_int32,
    pub did: *mut L_Rdid,
    pub rch: *mut L_Rch,
    pub rcha: *mut L_Rcha,
}
#[test]
fn bindgen_test_layout_L_Recog() {
    assert_eq!(
        ::std::mem::size_of::<L_Recog>(),
        320usize,
        concat!("Size of: ", stringify!(L_Recog))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Recog>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Recog))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).scalew as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scalew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).scaleh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scaleh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).linew as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(linew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).templ_use as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(templ_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxarraysize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxarraysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).setsize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(setsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).threshold as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxyshift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxyshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).charset_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).charset_size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).min_nopad as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_nopad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).num_samples as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(num_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minwidth_u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxwidth_u as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minheight_u as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minheight_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxheight_u as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxheight_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minwidth as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxwidth as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ave_done as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ave_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).train_done as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(train_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_wh_ratio as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_wh_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_ht_ratio as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_ht_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).min_splitw as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_splitw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_splith as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_splith)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).sa_text as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sa_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).dna_tochar as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(dna_tochar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).centtab as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(centtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).sumtab as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sumtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixaa_u as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ptaa_u as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).naasum_u as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixaa as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ptaa as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).naasum as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pta_u as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).nasum_u as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pta as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).nasum as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_tr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_tr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_ave as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_ave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_id as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixdb_ave as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_ave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixdb_range as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_boot as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_split as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).bmf as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).bmf_size as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).did as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).rch as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).rcha as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rcha)
        )
    );
}
pub type L_RECOG = L_Recog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rch {
    pub index: l_int32,
    pub score: l_float32,
    pub text: *mut ::std::os::raw::c_char,
    pub sample: l_int32,
    pub xloc: l_int32,
    pub yloc: l_int32,
    pub width: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rch() {
    assert_eq!(
        ::std::mem::size_of::<L_Rch>(),
        32usize,
        concat!("Size of: ", stringify!(L_Rch))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rch>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).score as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).sample as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).xloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(xloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).yloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(yloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(width)
        )
    );
}
pub type L_RCH = L_Rch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rcha {
    pub naindex: *mut Numa,
    pub nascore: *mut Numa,
    pub satext: *mut Sarray,
    pub nasample: *mut Numa,
    pub naxloc: *mut Numa,
    pub nayloc: *mut Numa,
    pub nawidth: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rcha() {
    assert_eq!(
        ::std::mem::size_of::<L_Rcha>(),
        56usize,
        concat!("Size of: ", stringify!(L_Rcha))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rcha>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rcha))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).naindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nascore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).satext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(satext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nasample as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nasample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).naxloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nayloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nayloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nawidth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nawidth)
        )
    );
}
pub type L_RCHA = L_Rcha;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rdid {
    pub pixs: *mut Pix,
    pub counta: *mut *mut l_int32,
    pub delya: *mut *mut l_int32,
    pub narray: l_int32,
    pub size: l_int32,
    pub setwidth: *mut l_int32,
    pub nasum: *mut Numa,
    pub namoment: *mut Numa,
    pub fullarrays: l_int32,
    pub beta: *mut l_float32,
    pub gamma: *mut l_float32,
    pub trellisscore: *mut l_float32,
    pub trellistempl: *mut l_int32,
    pub natempl: *mut Numa,
    pub naxloc: *mut Numa,
    pub nadely: *mut Numa,
    pub nawidth: *mut Numa,
    pub boxa: *mut Boxa,
    pub nascore: *mut Numa,
    pub natempl_r: *mut Numa,
    pub nasample_r: *mut Numa,
    pub naxloc_r: *mut Numa,
    pub nadely_r: *mut Numa,
    pub nawidth_r: *mut Numa,
    pub nascore_r: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rdid() {
    assert_eq!(
        ::std::mem::size_of::<L_Rdid>(),
        192usize,
        concat!("Size of: ", stringify!(L_Rdid))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rdid>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rdid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).counta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(counta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).delya as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(delya)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).narray as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(narray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).setwidth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(setwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nasum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).namoment as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(namoment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).fullarrays as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(fullarrays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).beta as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).gamma as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).trellisscore as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellisscore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).trellistempl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellistempl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).natempl as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).naxloc as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nadely as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nawidth as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).boxa as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nascore as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).natempl_r as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nasample_r as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasample_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).naxloc_r as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nadely_r as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nawidth_r as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nascore_r as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore_r)
        )
    );
}
pub type L_RDID = L_Rdid;
pub const L_UNKNOWN: _bindgen_ty_85 = 0;
pub const L_ARABIC_NUMERALS: _bindgen_ty_85 = 1;
pub const L_LC_ROMAN_NUMERALS: _bindgen_ty_85 = 2;
pub const L_UC_ROMAN_NUMERALS: _bindgen_ty_85 = 3;
pub const L_LC_ALPHA: _bindgen_ty_85 = 4;
pub const L_UC_ALPHA: _bindgen_ty_85 = 5;
pub type _bindgen_ty_85 = u32;
pub const L_USE_ALL_TEMPLATES: _bindgen_ty_86 = 0;
pub const L_USE_AVERAGE_TEMPLATES: _bindgen_ty_86 = 1;
pub type _bindgen_ty_86 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_RegParams {
    pub fp: *mut FILE,
    pub testname: *mut ::std::os::raw::c_char,
    pub tempfile: *mut ::std::os::raw::c_char,
    pub mode: l_int32,
    pub index: l_int32,
    pub success: l_int32,
    pub display: l_int32,
    pub tstart: L_TIMER,
}
#[test]
fn bindgen_test_layout_L_RegParams() {
    assert_eq!(
        ::std::mem::size_of::<L_RegParams>(),
        48usize,
        concat!("Size of: ", stringify!(L_RegParams))
    );
    assert_eq!(
        ::std::mem::align_of::<L_RegParams>(),
        8usize,
        concat!("Alignment of ", stringify!(L_RegParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).testname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(testname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).tempfile as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tempfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).index as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).success as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).display as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).tstart as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tstart)
        )
    );
}
pub type L_REGPARAMS = L_RegParams;
pub const L_REG_GENERATE: _bindgen_ty_87 = 0;
pub const L_REG_COMPARE: _bindgen_ty_87 = 1;
pub const L_REG_DISPLAY: _bindgen_ty_87 = 2;
pub type _bindgen_ty_87 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_StrCode {
    pub fileno: l_int32,
    pub ifunc: l_int32,
    pub function: *mut SARRAY,
    pub data: *mut SARRAY,
    pub descr: *mut SARRAY,
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_L_StrCode() {
    assert_eq!(
        ::std::mem::size_of::<L_StrCode>(),
        40usize,
        concat!("Size of: ", stringify!(L_StrCode))
    );
    assert_eq!(
        ::std::mem::align_of::<L_StrCode>(),
        8usize,
        concat!("Alignment of ", stringify!(L_StrCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).fileno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).ifunc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(ifunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).descr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(descr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(n)
        )
    );
}
pub type L_STRCODE = L_StrCode;
pub const L_STR_TYPE: _bindgen_ty_88 = 0;
pub const L_STR_NAME: _bindgen_ty_88 = 1;
pub const L_STR_READER: _bindgen_ty_88 = 2;
pub const L_STR_MEMREADER: _bindgen_ty_88 = 3;
pub type _bindgen_ty_88 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Sudoku {
    pub num: l_int32,
    pub locs: *mut l_int32,
    pub current: l_int32,
    pub init: *mut l_int32,
    pub state: *mut l_int32,
    pub nguess: l_int32,
    pub finished: l_int32,
    pub failure: l_int32,
}
#[test]
fn bindgen_test_layout_L_Sudoku() {
    assert_eq!(
        ::std::mem::size_of::<L_Sudoku>(),
        56usize,
        concat!("Size of: ", stringify!(L_Sudoku))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Sudoku>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Sudoku))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).locs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(locs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).current as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).nguess as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(nguess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).finished as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(finished)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).failure as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(failure)
        )
    );
}
pub type L_SUDOKU = L_Sudoku;
pub const L_SUDOKU_INIT: _bindgen_ty_89 = 0;
pub const L_SUDOKU_STATE: _bindgen_ty_89 = 1;
pub type _bindgen_ty_89 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WShed {
    pub pixs: *mut Pix,
    pub pixm: *mut Pix,
    pub mindepth: l_int32,
    pub pixlab: *mut Pix,
    pub pixt: *mut Pix,
    pub lines8: *mut *mut ::std::os::raw::c_void,
    pub linem1: *mut *mut ::std::os::raw::c_void,
    pub linelab32: *mut *mut ::std::os::raw::c_void,
    pub linet1: *mut *mut ::std::os::raw::c_void,
    pub pixad: *mut Pixa,
    pub ptas: *mut Pta,
    pub nasi: *mut Numa,
    pub nash: *mut Numa,
    pub namh: *mut Numa,
    pub nalevels: *mut Numa,
    pub nseeds: l_int32,
    pub nother: l_int32,
    pub lut: *mut l_int32,
    pub links: *mut *mut Numa,
    pub arraysize: l_int32,
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_WShed() {
    assert_eq!(
        ::std::mem::size_of::<L_WShed>(),
        152usize,
        concat!("Size of: ", stringify!(L_WShed))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WShed>(),
        8usize,
        concat!("Alignment of ", stringify!(L_WShed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).mindepth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(mindepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixlab as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixlab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).lines8 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lines8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linem1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linelab32 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linelab32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linet1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linet1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).ptas as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(ptas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nasi as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nasi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nash as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).namh as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(namh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nalevels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nalevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nseeds as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nseeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nother as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nother)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).lut as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).links as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).arraysize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(arraysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).debug as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(debug)
        )
    );
}
pub type L_WSHED = L_WShed;
extern "C" {
    pub fn pixCleanBackgroundToWhite(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormSimple(pixs: *mut PIX, pixim: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormGrayArray(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBackgroundNormRGBArrays(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBackgroundNormGrayArrayMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBackgroundNormRGBArraysMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetBackgroundGrayMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetBackgroundRGBMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetBackgroundGrayMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixm: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetBackgroundRGBMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFillMapHoles(pix: *mut PIX, nx: l_int32, ny: l_int32, filltype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixExtendByReplication(pixs: *mut PIX, addw: l_int32, addh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSmoothConnectedRegions(pixs: *mut PIX, pixm: *mut PIX, factor: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetInvBackgroundMap(
        pixs: *mut PIX,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundGrayMap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundRGBMap(
        pixs: *mut PIX,
        pixmr: *mut PIX,
        pixmg: *mut PIX,
        pixmb: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyVariableGrayMap(pixs: *mut PIX, pixg: *mut PIX, target: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        mapval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormNoSatRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        factor: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdSpreadNorm(
        pixs: *mut PIX,
        filtertype: l_int32,
        edgethresh: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
        targetthresh: l_int32,
        ppixth: *mut *mut PIX,
        ppixb: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBackgroundNormFlex(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastNorm(
        pixd: *mut PIX,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        mindiff: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMinMaxTiles(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        mindiff: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetLowContrast(pixs1: *mut PIX, pixs2: *mut PIX, mindiff: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixLinearTRCTiled(
        pixd: *mut PIX,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        pixmin: *mut PIX,
        pixmax: *mut PIX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffine(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getAffineXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn affineInvertXform(vc: *mut l_float32, pvci: *mut *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn affineXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn affineXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn linearInterpolatePixelColor(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        colorval: l_uint32,
        pval: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn linearInterpolatePixelGray(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        grayval: l_int32,
        pval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn gaussjordan(a: *mut *mut l_float32, b: *mut l_float32, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAffineSequential(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        bw: l_int32,
        bh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn createMatrix2dTranslate(transx: l_float32, transy: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dScale(scalex: l_float32, scaley: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dRotate(xc: l_float32, yc: l_float32, angle: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn ptaTranslate(ptas: *mut PTA, transx: l_float32, transy: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaScale(ptas: *mut PTA, scalex: l_float32, scaley: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaRotate(ptas: *mut PTA, xc: l_float32, yc: l_float32, angle: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaTranslate(boxas: *mut BOXA, transx: l_float32, transy: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaScale(boxas: *mut BOXA, scalex: l_float32, scaley: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaRotate(
        boxas: *mut BOXA,
        xc: l_float32,
        yc: l_float32,
        angle: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn ptaAffineTransform(ptas: *mut PTA, mat: *mut l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaAffineTransform(boxas: *mut BOXA, mat: *mut l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn l_productMatVec(
        mat: *mut l_float32,
        vecs: *mut l_float32,
        vecd: *mut l_float32,
        size: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_productMat2(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_productMat3(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_productMat4(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        mat4: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_getDataBit(line: *mut ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_clearDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_setDataBitVal(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataByte(line: *mut ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataByte(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataTwoBytes(line: *mut ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataTwoBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataFourBytes(line: *mut ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataFourBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn barcodeDispatchDecoder(
        barstr: *mut ::std::os::raw::c_char,
        format: l_int32,
        debugflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn barcodeFormatIsSupported(format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixFindBaselines(pixs: *mut PIX, ppta: *mut *mut PTA, pixadb: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixDeskewLocal(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetLocalSkewTransform(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pptas: *mut *mut PTA,
        pptad: *mut *mut PTA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetLocalSkewAngles(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pa: *mut l_float32,
        pb: *mut l_float32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bbufferCreate(indata: *mut l_uint8, nalloc: l_int32) -> *mut L_BBUFFER;
}
extern "C" {
    pub fn bbufferDestroy(pbb: *mut *mut L_BBUFFER);
}
extern "C" {
    pub fn bbufferDestroyAndSaveData(pbb: *mut *mut L_BBUFFER, pnbytes: *mut usize)
        -> *mut l_uint8;
}
extern "C" {
    pub fn bbufferRead(bb: *mut L_BBUFFER, src: *mut l_uint8, nbytes: l_int32) -> l_int32;
}
extern "C" {
    pub fn bbufferReadStream(bb: *mut L_BBUFFER, fp: *mut FILE, nbytes: l_int32) -> l_int32;
}
extern "C" {
    pub fn bbufferExtendArray(bb: *mut L_BBUFFER, nbytes: l_int32) -> l_int32;
}
extern "C" {
    pub fn bbufferWrite(
        bb: *mut L_BBUFFER,
        dest: *mut l_uint8,
        nbytes: usize,
        pnout: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn bbufferWriteStream(
        bb: *mut L_BBUFFER,
        fp: *mut FILE,
        nbytes: usize,
        pnout: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBilateral(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGray(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGrayExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockBilateralExact(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRangeKernel(range_stdev: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn pixBilinearSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinear(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getBilinearXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn bilinearXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn bilinearXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixOtsuAdaptiveThreshold(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixOtsuThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskedThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSauvolaBinarizeTiled(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        nx: l_int32,
        ny: l_int32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSauvolaBinarize(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        addborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixsd: *mut *mut PIX,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSauvolaGetThreshold(
        pixm: *mut PIX,
        pixms: *mut PIX,
        factor: l_float32,
        ppixsd: *mut *mut PIX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyLocalThreshold(pixs: *mut PIX, pixth: *mut PIX, redfactor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdByConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        start: l_int32,
        end: l_int32,
        incr: l_int32,
        thresh48: l_float32,
        threshdiff: l_float32,
        pglobthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixExpandBinaryReplicate(pixs: *mut PIX, xfact: l_int32, yfact: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandBinaryPower2(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceBinary2(pixs: *mut PIX, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinaryCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinary2(pixs: *mut PIX, level: l_int32, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn makeSubsampleTab2x() -> *mut l_uint8;
}
extern "C" {
    pub fn pixBlend(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendMask(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGray(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayInverse(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColor(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColorByChannel(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayAdapt(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        shift: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFadeWithGray(
        pixs: *mut PIX,
        pixb: *mut PIX,
        factor: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendHardLight(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendCmap(
        pixs: *mut PIX,
        pixb: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBlendWithGrayMask(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        pixg: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBackgroundToColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyByColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAlphaBlendUniform(pixs: *mut PIX, color: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaToBlend(pixs: *mut PIX, fract: l_float32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetAlphaOverWhite(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearEdgeFade(
        pixs: *mut PIX,
        dir: l_int32,
        fadeto: l_int32,
        distfract: l_float32,
        maxfade: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn bmfCreate(dir: *const ::std::os::raw::c_char, fontsize: l_int32) -> *mut L_BMF;
}
extern "C" {
    pub fn bmfDestroy(pbmf: *mut *mut L_BMF);
}
extern "C" {
    pub fn bmfGetPix(bmf: *mut L_BMF, chr: ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn bmfGetWidth(bmf: *mut L_BMF, chr: ::std::os::raw::c_char, pw: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn bmfGetBaseline(
        bmf: *mut L_BMF,
        chr: ::std::os::raw::c_char,
        pbaseline: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaGetFont(
        dir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
        pbl0: *mut l_int32,
        pbl1: *mut l_int32,
        pbl2: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSaveFont(
        indir: *const ::std::os::raw::c_char,
        outdir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadStreamBmp(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemBmp(cdata: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamBmp(fp: *mut FILE, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemBmp(pfdata: *mut *mut l_uint8, pfsize: *mut usize, pixs: *mut PIX)
        -> l_int32;
}
extern "C" {
    pub fn l_bootnum_gen1() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen2() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen3() -> *mut PIXA;
}
extern "C" {
    pub fn boxCreate(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCreateValid(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCopy(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxClone(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxDestroy(pbox: *mut *mut BOX);
}
extern "C" {
    pub fn boxGetGeometry(
        box_: *mut BOX,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxSetGeometry(
        box_: *mut BOX,
        x: l_int32,
        y: l_int32,
        w: l_int32,
        h: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxGetSideLocations(
        box_: *mut BOX,
        pl: *mut l_int32,
        pr: *mut l_int32,
        pt: *mut l_int32,
        pb: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxSetSideLocations(
        box_: *mut BOX,
        l: l_int32,
        r: l_int32,
        t: l_int32,
        b: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxGetRefcount(box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxChangeRefcount(box_: *mut BOX, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxIsValid(box_: *mut BOX, pvalid: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaCreate(n: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCopy(boxa: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaDestroy(pboxa: *mut *mut BOXA);
}
extern "C" {
    pub fn boxaAddBox(boxa: *mut BOXA, box_: *mut BOX, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaExtendArray(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaExtendArrayToSize(boxa: *mut BOXA, size: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaGetCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetValidCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetValidBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindInvalidBoxes(boxa: *mut BOXA) -> *mut NUMA;
}
extern "C" {
    pub fn boxaGetBoxGeometry(
        boxa: *mut BOXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaIsFull(boxa: *mut BOXA, pfull: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaReplaceBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxaInsertBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxaRemoveBox(boxa: *mut BOXA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaRemoveBoxAndSave(boxa: *mut BOXA, index: l_int32, pbox: *mut *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxaSaveValid(boxas: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaInitFull(boxa: *mut BOXA, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxaClear(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaaCreate(n: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaCopy(baas: *mut BOXAA, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaDestroy(pbaa: *mut *mut BOXAA);
}
extern "C" {
    pub fn boxaaAddBoxa(baa: *mut BOXAA, ba: *mut BOXA, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaaExtendArray(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaExtendArrayToSize(baa: *mut BOXAA, size: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaaGetCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxa(baa: *mut BOXAA, index: l_int32, accessflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaGetBox(
        baa: *mut BOXAA,
        iboxa: l_int32,
        ibox: l_int32,
        accessflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaaInitFull(baa: *mut BOXAA, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaaExtendWithInit(baa: *mut BOXAA, maxindex: l_int32, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaaReplaceBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaaInsertBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaaRemoveBoxa(baa: *mut BOXAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaaAddBox(
        baa: *mut BOXAA,
        index: l_int32,
        box_: *mut BOX,
        accessflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadStream(fp: *mut FILE) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadMem(data: *const l_uint8, size: usize) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaWrite(filename: *const ::std::os::raw::c_char, baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaWriteStream(fp: *mut FILE, baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadStream(fp: *mut FILE) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadMem(data: *const l_uint8, size: usize) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWrite(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaWriteStream(fp: *mut FILE, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxPrintStreamInfo(fp: *mut FILE, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxContains(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxIntersects(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaContainedInBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaContainedInBoxCount(
        boxa: *mut BOXA,
        box_: *mut BOX,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaContainedInBoxa(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        pcontained: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaIntersectsBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaIntersectsBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32)
        -> l_int32;
}
extern "C" {
    pub fn boxaClipToBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlaps(boxas: *mut BOXA, pixadb: *mut PIXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlapsInPair(
        boxas1: *mut BOXA,
        boxas2: *mut BOXA,
        pboxad1: *mut *mut BOXA,
        pboxad2: *mut *mut BOXA,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn boxOverlapRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxBoundingRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxOverlapFraction(box1: *mut BOX, box2: *mut BOX, pfract: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn boxOverlapArea(box1: *mut BOX, box2: *mut BOX, parea: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaHandleOverlaps(
        boxas: *mut BOXA,
        op: l_int32,
        range: l_int32,
        min_overlap: l_float32,
        max_ratio: l_float32,
        pnamap: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxSeparationDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_sep: *mut l_int32,
        pv_sep: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxCompareSize(
        box1: *mut BOX,
        box2: *mut BOX,
        type_: l_int32,
        prel: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxContainsPt(
        box_: *mut BOX,
        x: l_float32,
        y: l_float32,
        pcontains: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetNearestToPt(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetNearestToLine(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindNearestBoxes(
        boxa: *mut BOXA,
        dist_select: l_int32,
        range: l_int32,
        pnaaindex: *mut *mut NUMAA,
        pnaadist: *mut *mut NUMAA,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetNearestByDirection(
        boxa: *mut BOXA,
        i: l_int32,
        dir: l_int32,
        dist_select: l_int32,
        range: l_int32,
        pindex: *mut l_int32,
        pdist: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxGetCenter(box_: *mut BOX, pcx: *mut l_float32, pcy: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn boxIntersectByLine(
        box_: *mut BOX,
        x: l_int32,
        y: l_int32,
        slope: l_float32,
        px1: *mut l_int32,
        py1: *mut l_int32,
        px2: *mut l_int32,
        py2: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxClipToRectangle(box_: *mut BOX, wi: l_int32, hi: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxClipToRectangleParams(
        box_: *mut BOX,
        w: l_int32,
        h: l_int32,
        pxstart: *mut l_int32,
        pystart: *mut l_int32,
        pxend: *mut l_int32,
        pyend: *mut l_int32,
        pbw: *mut l_int32,
        pbh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxRelocateOneSide(
        boxd: *mut BOX,
        boxs: *mut BOX,
        loc: l_int32,
        sideflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaAdjustSides(
        boxas: *mut BOXA,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxAdjustSides(
        boxd: *mut BOX,
        boxs: *mut BOX,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSetSide(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        side: l_int32,
        val: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustWidthToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustHeightToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxEqual(box1: *mut BOX, box2: *mut BOX, psame: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaEqual(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxSimilar(
        box1: *mut BOX,
        box2: *mut BOX,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        psimilar: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaSimilar(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        debug: l_int32,
        psimilar: *mut l_int32,
        pnasim: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaJoin(boxad: *mut BOXA, boxas: *mut BOXA, istart: l_int32, iend: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaaJoin(baad: *mut BOXAA, baas: *mut BOXAA, istart: l_int32, iend: l_int32)
        -> l_int32;
}
extern "C" {
    pub fn boxaSplitEvenOdd(
        boxa: *mut BOXA,
        fillflag: l_int32,
        pboxae: *mut *mut BOXA,
        pboxao: *mut *mut BOXA,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaMergeEvenOdd(boxae: *mut BOXA, boxao: *mut BOXA, fillflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaTransform(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransform(
        box_: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaTransformOrdered(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransformOrdered(
        boxs: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaRotateOrth(boxas: *mut BOXA, w: l_int32, h: l_int32, rotation: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxRotateOrth(box_: *mut BOX, w: l_int32, h: l_int32, rotation: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaBinSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSortByIndex(boxas: *mut BOXA, naindex: *mut NUMA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort2d(
        boxas: *mut BOXA,
        pnaad: *mut *mut NUMAA,
        delta1: l_int32,
        delta2: l_int32,
        minh1: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSort2dByIndex(boxas: *mut BOXA, naa: *mut NUMAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaExtractAsNuma(
        boxa: *mut BOXA,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        keepinvalid: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaExtractAsPta(
        boxa: *mut BOXA,
        pptal: *mut *mut PTA,
        pptat: *mut *mut PTA,
        pptar: *mut *mut PTA,
        pptab: *mut *mut PTA,
        pptaw: *mut *mut PTA,
        pptah: *mut *mut PTA,
        keepinvalid: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetRankVals(
        boxa: *mut BOXA,
        fract: l_float32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetMedianVals(
        boxa: *mut BOXA,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetAverageSize(boxa: *mut BOXA, pw: *mut l_float32, ph: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn boxaaGetExtent(
        baa: *mut BOXAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
        pboxa: *mut *mut BOXA,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaaFlattenToBoxa(
        baa: *mut BOXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaFlattenAligned(
        baa: *mut BOXAA,
        num: l_int32,
        fillerbox: *mut BOX,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaEncapsulateAligned(boxa: *mut BOXA, num: l_int32, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaTranspose(baas: *mut BOXAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaAlignBox(
        baa: *mut BOXAA,
        box_: *mut BOX,
        delta: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMaskConnComp(
        pixs: *mut PIX,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskBoxa(pixd: *mut PIX, pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxa(pixs: *mut PIX, boxa: *mut BOXA, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetBlackOrWhiteBoxa(pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxa(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn boxaaDisplay(
        pixs: *mut PIX,
        baa: *mut BOXAA,
        linewba: l_int32,
        linewb: l_int32,
        colorba: l_uint32,
        colorb: l_uint32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayBoxaa(
        pixas: *mut PIXA,
        baa: *mut BOXAA,
        colorflag: l_int32,
        width: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSplitIntoBoxa(
        pixs: *mut PIX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixSplitComponentIntoBoxa(
        pix: *mut PIX,
        box_: *mut BOX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn makeMosaicStrips(w: l_int32, h: l_int32, direction: l_int32, size: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxaCompareRegions(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        areathresh: l_int32,
        pnsame: *mut l_int32,
        pdiffarea: *mut l_float32,
        pdiffxor: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSelectLargeULComp(
        pixs: *mut PIX,
        areaslop: l_float32,
        yslop: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectLargeULBox(boxas: *mut BOXA, areaslop: l_float32, yslop: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectRange(
        boxas: *mut BOXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaSelectRange(
        baas: *mut BOXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSelectBySize(
        boxas: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeSizeIndicator(
        boxa: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByArea(
        boxas: *mut BOXA,
        area: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeAreaIndicator(boxa: *mut BOXA, area: l_int32, relation: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByWHRatio(
        boxas: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeWHRatioIndicator(
        boxa: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectWithIndicator(
        boxas: *mut BOXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermutePseudorandom(boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermuteRandom(boxad: *mut BOXA, boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSwapBoxes(boxa: *mut BOXA, i: l_int32, j: l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaConvertToPta(boxa: *mut BOXA, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBoxa(pta: *mut PTA, ncorners: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxConvertToPta(box_: *mut BOX, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBox(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn boxaSmoothSequenceLS(
        boxas: *mut BOXA,
        factor: l_float32,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
        debug: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSmoothSequenceMedian(
        boxas: *mut BOXA,
        halfwin: l_int32,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
        debug: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaLinearFit(boxas: *mut BOXA, factor: l_float32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWindowedMedian(boxas: *mut BOXA, halfwin: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaModifyWithBoxa(
        boxas: *mut BOXA,
        boxam: *mut BOXA,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaConstrainSize(
        boxas: *mut BOXA,
        width: l_int32,
        widthflag: l_int32,
        height: l_int32,
        heightflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileEvenOddHeight(
        boxas: *mut BOXA,
        sides: l_int32,
        delh: l_int32,
        op: l_int32,
        factor: l_float32,
        start: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcilePairWidth(
        boxas: *mut BOXA,
        delw: l_int32,
        op: l_int32,
        factor: l_float32,
        na: *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPlotSides(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaPlotSizes(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaFillSequence(boxas: *mut BOXA, useflag: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaGetExtent(
        boxa: *mut BOXA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetCoverage(
        boxa: *mut BOXA,
        wc: l_int32,
        hc: l_int32,
        exactflag: l_int32,
        pfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaaSizeRange(
        baa: *mut BOXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaSizeRange(
        boxa: *mut BOXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaLocationRange(
        boxa: *mut BOXA,
        pminx: *mut l_int32,
        pminy: *mut l_int32,
        pmaxx: *mut l_int32,
        pmaxy: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaGetSizes(boxa: *mut BOXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn boxaGetArea(boxa: *mut BOXA, parea: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn boxaDisplayTiled(
        boxas: *mut BOXA,
        pixa: *mut PIXA,
        maxwidth: l_int32,
        linewidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_byteaCreate(nbytes: usize) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromMem(data: *mut l_uint8, size: usize) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromFile(fname: *const ::std::os::raw::c_char) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromStream(fp: *mut FILE) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaCopy(bas: *mut L_BYTEA, copyflag: l_int32) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaDestroy(pba: *mut *mut L_BYTEA);
}
extern "C" {
    pub fn l_byteaGetSize(ba: *mut L_BYTEA) -> usize;
}
extern "C" {
    pub fn l_byteaGetData(ba: *mut L_BYTEA, psize: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaCopyData(ba: *mut L_BYTEA, psize: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaAppendData(ba: *mut L_BYTEA, newdata: *mut l_uint8, newbytes: usize) -> l_int32;
}
extern "C" {
    pub fn l_byteaAppendString(ba: *mut L_BYTEA, str: *mut ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn l_byteaJoin(ba1: *mut L_BYTEA, pba2: *mut *mut L_BYTEA) -> l_int32;
}
extern "C" {
    pub fn l_byteaSplit(ba1: *mut L_BYTEA, splitloc: usize, pba2: *mut *mut L_BYTEA) -> l_int32;
}
extern "C" {
    pub fn l_byteaFindEachSequence(
        ba: *mut L_BYTEA,
        sequence: *mut l_uint8,
        seqlen: l_int32,
        pda: *mut *mut L_DNA,
    ) -> l_int32;
}
extern "C" {
    pub fn l_byteaWrite(
        fname: *const ::std::os::raw::c_char,
        ba: *mut L_BYTEA,
        startloc: usize,
        endloc: usize,
    ) -> l_int32;
}
extern "C" {
    pub fn l_byteaWriteStream(
        fp: *mut FILE,
        ba: *mut L_BYTEA,
        startloc: usize,
        endloc: usize,
    ) -> l_int32;
}
extern "C" {
    pub fn ccbaCreate(pixs: *mut PIX, n: l_int32) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaDestroy(pccba: *mut *mut CCBORDA);
}
extern "C" {
    pub fn ccbCreate(pixs: *mut PIX) -> *mut CCBORD;
}
extern "C" {
    pub fn ccbDestroy(pccb: *mut *mut CCBORD);
}
extern "C" {
    pub fn ccbaAddCcb(ccba: *mut CCBORDA, ccb: *mut CCBORD) -> l_int32;
}
extern "C" {
    pub fn ccbaGetCount(ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaGetCcb(ccba: *mut CCBORDA, index: l_int32) -> *mut CCBORD;
}
extern "C" {
    pub fn pixGetAllCCBorders(pixs: *mut PIX) -> *mut CCBORDA;
}
extern "C" {
    pub fn pixGetCCBorders(pixs: *mut PIX, box_: *mut BOX) -> *mut CCBORD;
}
extern "C" {
    pub fn pixGetOuterBordersPtaa(pixs: *mut PIX) -> *mut PTAA;
}
extern "C" {
    pub fn pixGetOuterBorderPta(pixs: *mut PIX, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixGetOuterBorder(ccb: *mut CCBORD, pixs: *mut PIX, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn pixGetHoleBorder(
        ccb: *mut CCBORD,
        pixs: *mut PIX,
        box_: *mut BOX,
        xs: l_int32,
        ys: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn findNextBorderPixel(
        w: l_int32,
        h: l_int32,
        data: *mut l_uint32,
        wpl: l_int32,
        px: l_int32,
        py: l_int32,
        pqpos: *mut l_int32,
        pnpx: *mut l_int32,
        pnpy: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn locateOutsideSeedPixel(
        fpx: l_int32,
        fpy: l_int32,
        spx: l_int32,
        spy: l_int32,
        pxs: *mut l_int32,
        pys: *mut l_int32,
    );
}
extern "C" {
    pub fn ccbaGenerateGlobalLocs(ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaGenerateStepChains(ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaStepChainsToPixCoords(ccba: *mut CCBORDA, coordtype: l_int32) -> l_int32;
}
extern "C" {
    pub fn ccbaGenerateSPGlobalLocs(ccba: *mut CCBORDA, ptsflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn ccbaGenerateSinglePath(ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn getCutPathForHole(
        pix: *mut PIX,
        pta: *mut PTA,
        boxinner: *mut BOX,
        pdir: *mut l_int32,
        plen: *mut l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ccbaDisplayBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplaySPBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage1(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage2(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaWrite(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaWriteStream(fp: *mut FILE, ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaRead(filename: *const ::std::os::raw::c_char) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaReadStream(fp: *mut FILE) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaWriteSVG(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaWriteSVGString(
        filename: *const ::std::os::raw::c_char,
        ccba: *mut CCBORDA,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixaThinConnected(
        pixas: *mut PIXA,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixThinConnected(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThinConnectedBySet(
        pixs: *mut PIX,
        type_: l_int32,
        sela: *mut SELA,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaMakeThinSets(index: l_int32, debug: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn jbCorrelation(
        dirin: *const ::std::os::raw::c_char,
        thresh: l_float32,
        weight: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbRankHaus(
        dirin: *const ::std::os::raw::c_char,
        size: l_int32,
        rank: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbWordsInTextlines(
        dirin: *const ::std::os::raw::c_char,
        reduction: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weight: l_float32,
        pnatl: *mut *mut NUMA,
        firstpage: l_int32,
        npages: l_int32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn pixGetWordsInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
        pnai: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetWordBoxesInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        pnai: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaExtractSortedPattern(boxa: *mut BOXA, na: *mut NUMA) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCompareImagesByBoxes(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        nperline: l_int32,
        nreq: l_int32,
        maxshiftx: l_int32,
        maxshifty: l_int32,
        delx: l_int32,
        dely: l_int32,
        psame: *mut l_int32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorContent(
        pixs: *mut PIX,
        rwhite: l_int32,
        gwhite: l_int32,
        bwhite: l_int32,
        mingray: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorMagnitude(
        pixs: *mut PIX,
        rwhite: l_int32,
        gwhite: l_int32,
        bwhite: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorPixels(
        pixs: *mut PIX,
        threshdiff: l_int32,
        mindist: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorRange(
        pixs: *mut PIX,
        rmin: l_int32,
        rmax: l_int32,
        gmin: l_int32,
        gmax: l_int32,
        bmin: l_int32,
        bmax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorFraction(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        factor: l_int32,
        ppixfract: *mut l_float32,
        pcolorfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindColorRegions(
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_int32,
        lightthresh: l_int32,
        darkthresh: l_int32,
        mindiff: l_int32,
        colordiff: l_int32,
        edgefract: l_float32,
        pcolorfract: *mut l_float32,
        pcolormask1: *mut *mut PIX,
        pcolormask2: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixNumSignificantGrayColors(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        minfract: l_float32,
        factor: l_int32,
        pncolors: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorsForQuantization(
        pixs: *mut PIX,
        thresh: l_int32,
        pncolors: *mut l_int32,
        piscolor: *mut l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixNumColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetMostPopulatedColors(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
        parray: *mut *mut l_uint32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSimpleColorQuantize(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBHistogram(pixs: *mut PIX, sigbits: l_int32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn makeRGBIndexTables(
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
        sigbits: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn getRGBFromIndex(
        index: l_uint32,
        sigbits: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixHasHighlightRed(
        pixs: *mut PIX,
        factor: l_int32,
        fract: l_float32,
        fthresh: l_float32,
        phasred: *mut l_int32,
        pratio: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorGrayRegions(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorGray(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorGrayMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColorCmap(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearMapToTargetColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelLinearMapToTargetColor(
        scolor: l_uint32,
        srcmap: l_uint32,
        dstmap: l_uint32,
        pdcolor: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixShiftByComponent(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelShiftByComponent(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        srcval: l_uint32,
        dstval: l_uint32,
        ppixel: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixelFractionalShift(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fraction: l_float32,
        ppixel: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapCreate(depth: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateRandom(
        depth: l_int32,
        hasblack: l_int32,
        haswhite: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateLinear(d: l_int32, nlevels: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCopy(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapDestroy(pcmap: *mut *mut PIXCMAP);
}
extern "C" {
    pub fn pixcmapAddColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapAddRGBA(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapAddNewColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapAddNearestColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapUsableColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pusable: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapAddBlackOrWhite(
        cmap: *mut PIXCMAP,
        color: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapSetBlackAndWhite(
        cmap: *mut PIXCMAP,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetCount(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetFreeCount(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetDepth(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetMinDepth(cmap: *mut PIXCMAP, pmindepth: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixcmapClear(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetColor32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetRGBA(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetRGBA32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixcmapResetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapSetAlpha(cmap: *mut PIXCMAP, index: l_int32, aval: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapHasColor(cmap: *mut PIXCMAP, pcolor: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixcmapIsOpaque(cmap: *mut PIXCMAP, popaque: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixcmapIsBlackAndWhite(cmap: *mut PIXCMAP, pblackwhite: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixcmapCountGrayColors(cmap: *mut PIXCMAP, pngray: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetRankIntensity(
        cmap: *mut PIXCMAP,
        rankval: l_float32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetNearestIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetNearestGrayIndex(
        cmap: *mut PIXCMAP,
        val: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetDistanceToColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pdist: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetRangeValues(
        cmap: *mut PIXCMAP,
        select: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pminindex: *mut l_int32,
        pmaxindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapGrayToColor(color: l_uint32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapColorToGray(
        cmaps: *mut PIXCMAP,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo4(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo8(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapRead(filename: *const ::std::os::raw::c_char) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadStream(fp: *mut FILE) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadMem(data: *const l_uint8, size: usize) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapWrite(filename: *const ::std::os::raw::c_char, cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapWriteStream(fp: *mut FILE, cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        cmap: *mut PIXCMAP,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapToArrays(
        cmap: *mut PIXCMAP,
        prmap: *mut *mut l_int32,
        pgmap: *mut *mut l_int32,
        pbmap: *mut *mut l_int32,
        pamap: *mut *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapToRGBTable(
        cmap: *mut PIXCMAP,
        ptab: *mut *mut l_uint32,
        pncolors: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapSerializeToMemory(
        cmap: *mut PIXCMAP,
        cpc: l_int32,
        pncolors: *mut l_int32,
        pdata: *mut *mut l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapDeserializeFromMemory(
        data: *mut l_uint8,
        cpc: l_int32,
        ncolors: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertToHex(data: *mut l_uint8, ncolors: l_int32)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixcmapGammaTRC(
        cmap: *mut PIXCMAP,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapContrastTRC(cmap: *mut PIXCMAP, factor: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixcmapShiftIntensity(cmap: *mut PIXCMAP, fraction: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixcmapShiftByComponent(
        cmap: *mut PIXCMAP,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorMorph(
        pixs: *mut PIX,
        type_: l_int32,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuant(pixs: *mut PIX, colors: l_int32, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuantGeneral(
        pixs: *mut PIX,
        colors: l_int32,
        ditherflag: l_int32,
        validthresh: l_float32,
        colorthresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRGBToIndexTables(
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
        cqlevels: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn getOctcubeIndexFromRGB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        rtab: *mut l_uint32,
        gtab: *mut l_uint32,
        btab: *mut l_uint32,
        pindex: *mut l_uint32,
    );
}
extern "C" {
    pub fn pixOctreeQuantByPopulation(
        pixs: *mut PIX,
        level: l_int32,
        ditherflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeQuantNumColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        subsample: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantMixedWithGray(
        pixs: *mut PIX,
        depth: l_int32,
        graylevels: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuant256(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant1(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant2(
        pixs: *mut PIX,
        level: l_int32,
        na: *mut NUMA,
        ncolors: l_int32,
        pnerrors: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuantMixed(
        pixs: *mut PIX,
        level: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        minfract: l_float32,
        maxspan: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuantGenRGB(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeHistogram(pixs: *mut PIX, level: l_int32, pncolors: *mut l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixcmapToOctcubeLUT(cmap: *mut PIXCMAP, level: l_int32, metric: l_int32)
        -> *mut l_int32;
}
extern "C" {
    pub fn pixRemoveUnusedColors(pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixNumberOccupiedOctcubes(
        pix: *mut PIX,
        level: l_int32,
        mincount: l_int32,
        minfract: l_float32,
        pncolors: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMedianCutQuant(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantGeneral(
        pixs: *mut PIX,
        ditherflag: l_int32,
        outdepth: l_int32,
        maxcolors: l_int32,
        sigbits: l_int32,
        maxsub: l_int32,
        checkbw: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        maxncolors: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutHisto(pixs: *mut PIX, sigbits: l_int32, subsample: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn pixColorSegment(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        selsize: l_int32,
        finalcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorSegmentCluster(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAssignToNearestColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        level: l_int32,
        countarray: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorSegmentClean(
        pixs: *mut PIX,
        selsize: l_int32,
        countarray: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorSegmentRemoveColors(
        pixd: *mut PIX,
        pixs: *mut PIX,
        finalcolors: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvertRGBToHSV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertHSVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToHSV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        phval: *mut l_int32,
        psval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertHSVToRGB(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapConvertRGBToHSV(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapConvertHSVToRGB(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixConvertRGBToHue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToSaturation(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToValue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHS(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        satcenter: l_int32,
        sathw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHV(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskSV(
        pixs: *mut PIX,
        satcenter: l_int32,
        sathw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHS(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnasat: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHV(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoSV(
        pixs: *mut PIX,
        factor: l_int32,
        pnasat: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHistoPeaksHSV(
        pixs: *mut PIX,
        type_: l_int32,
        width: l_int32,
        height: l_int32,
        npeaks: l_int32,
        erasefactor: l_float32,
        ppta: *mut *mut PTA,
        pnatot: *mut *mut NUMA,
        ppixa: *mut *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn displayHSVColorRange(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        huehw: l_int32,
        sathw: l_int32,
        nsamp: l_int32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToYUV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertYUVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToYUV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pyval: *mut l_int32,
        puval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertYUVToRGB(
        yval: l_int32,
        uval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapConvertRGBToYUV(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapConvertYUVToRGB(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixConvertRGBToXYZ(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertXYZToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToXYZ(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pfxval: *mut l_float32,
        pfyval: *mut l_float32,
        pfzval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertXYZToRGB(
        fxval: l_float32,
        fyval: l_float32,
        fzval: l_float32,
        blackout: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixaConvertXYZToLAB(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToXYZ(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn convertXYZToLAB(
        xval: l_float32,
        yval: l_float32,
        zval: l_float32,
        plval: *mut l_float32,
        paval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertLABToXYZ(
        lval: l_float32,
        aval: l_float32,
        bval: l_float32,
        pxval: *mut l_float32,
        pyval: *mut l_float32,
        pzval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvertRGBToLAB(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToLAB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pflval: *mut l_float32,
        pfaval: *mut l_float32,
        pfbval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertLABToRGB(
        flval: l_float32,
        faval: l_float32,
        fbval: l_float32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixEqual(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixEqualWithAlpha(
        pix1: *mut PIX,
        pix2: *mut PIX,
        use_alpha: l_int32,
        psame: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixEqualWithCmap(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn cmapEqual(
        cmap1: *mut PIXCMAP,
        cmap2: *mut PIXCMAP,
        ncomps: l_int32,
        psame: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUsesCmapColor(pixs: *mut PIX, pcolor: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationBinary(pix1: *mut PIX, pix2: *mut PIX, pval: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixDisplayDiffBinary(pix1: *mut PIX, pix2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCompareBinary(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        pfract: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCompareGrayOrRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCompareGray(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCompareRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCompareTiled(
        pix1: *mut PIX,
        pix2: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixdiff: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCompareRankDifference(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTestForSimilarity(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        maxfract: l_float32,
        maxave: l_float32,
        psimilar: *mut l_int32,
        details: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetDifferenceStats(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        pfractdiff: *mut l_float32,
        pavediff: *mut l_float32,
        details: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetDifferenceHistogram(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetPerceptualDiff(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        sampling: l_int32,
        dilation: l_int32,
        mindiff: l_int32,
        pfract: *mut l_float32,
        ppixdiff1: *mut *mut PIX,
        ppixdiff2: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetPSNR(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        ppsnr: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaComparePhotoRegionsByHisto(
        pixa: *mut PIXA,
        minratio: l_float32,
        textthresh: l_float32,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
        simthresh: l_float32,
        pnai: *mut *mut NUMA,
        pscores: *mut *mut l_float32,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixComparePhotoRegionsByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGenPhotoHistos(
        pixs: *mut PIX,
        box_: *mut BOX,
        factor: l_int32,
        thresh: l_float32,
        nx: l_int32,
        ny: l_int32,
        pnaa: *mut *mut NUMAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixPadToCenterCentroid(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCentroid8(
        pixs: *mut PIX,
        factor: l_int32,
        pcx: *mut l_float32,
        pcy: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDecideIfPhotoImage(
        pix: *mut PIX,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
        thresh: l_float32,
        pnaa: *mut *mut NUMAA,
        pixadebug: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn compareTilesByHisto(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        minratio: l_float32,
        w1: l_int32,
        h1: l_int32,
        w2: l_int32,
        h2: l_int32,
        pscore: *mut l_float32,
        pixadebug: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCompareGrayByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        maxgray: l_int32,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCropAlignedToCentroid(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        pbox1: *mut *mut BOX,
        pbox2: *mut *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn l_compressGrayHistograms(
        naa: *mut NUMAA,
        w: l_int32,
        h: l_int32,
        psize: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_uncompressGrayHistograms(
        bytea: *mut l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixCompareWithTranslation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        thresh: l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBestCorrelation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        etransx: l_int32,
        etransy: l_int32,
        maxshift: l_int32,
        tab8: *mut l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConnComp(pixs: *mut PIX, ppixa: *mut *mut PIXA, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompPixa(
        pixs: *mut PIX,
        ppixa: *mut *mut PIXA,
        connectivity: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompBB(pixs: *mut PIX, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixCountConnComp(pixs: *mut PIX, connectivity: l_int32, pcount: *mut l_int32)
        -> l_int32;
}
extern "C" {
    pub fn nextOnPixelInRaster(
        pixs: *mut PIX,
        xstart: l_int32,
        ystart: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn nextOnPixelInRasterLow(
        data: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpl: l_int32,
        xstart: l_int32,
        ystart: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillBB(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill4BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill8BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfill4(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSeedfill8(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn convertFilesTo1bpp(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        upscaling: l_int32,
        thresh: l_int32,
        firstpage: l_int32,
        npages: l_int32,
        dirout: *const ::std::os::raw::c_char,
        outformat: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixBlockconv(pix: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGray(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvAccum(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayUnnormalized(pixs: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvTiled(
        pix: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayTile(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedStats(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixms: *mut *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWindowedMean(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedMeanSquare(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedVariance(
        pixm: *mut PIX,
        pixms: *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMeanSquareAccum(pixs: *mut PIX) -> *mut DPIX;
}
extern "C" {
    pub fn pixBlockrank(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlocksum(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCensusTransform(pixs: *mut PIX, halfsize: l_int32, pixacc: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolve(
        pixs: *mut PIX,
        kel: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveSep(
        pixs: *mut PIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGB(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGBSep(pixs: *mut PIX, kelx: *mut L_KERNEL, kely: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvolve(fpixs: *mut FPIX, kel: *mut L_KERNEL, normflag: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixConvolveSep(
        fpixs: *mut FPIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        normflag: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvolveWithBias(
        pixs: *mut PIX,
        kel1: *mut L_KERNEL,
        kel2: *mut L_KERNEL,
        force8: l_int32,
        pbias: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setConvolveSampling(xfact: l_int32, yfact: l_int32);
}
extern "C" {
    pub fn pixAddGaussianNoise(pixs: *mut PIX, stdev: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn gaussDistribSampling() -> l_float32;
}
extern "C" {
    pub fn pixCorrelationScore(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreThresholded(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        downcount: *mut l_int32,
        score_threshold: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreSimple(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreShifted(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_int32,
        dely: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpCreate(pixs: *mut PIX, pageno: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpCreateRef(pageno: l_int32, refpage: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpDestroy(pdew: *mut *mut L_DEWARP);
}
extern "C" {
    pub fn dewarpaCreate(
        nptrs: l_int32,
        sampling: l_int32,
        redfactor: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaCreateFromPixacomp(
        pixac: *mut PIXAC,
        useboth: l_int32,
        sampling: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaDestroy(pdewa: *mut *mut L_DEWARPA);
}
extern "C" {
    pub fn dewarpaDestroyDewarp(dewa: *mut L_DEWARPA, pageno: l_int32) -> l_int32;
}
extern "C" {
    pub fn dewarpaInsertDewarp(dewa: *mut L_DEWARPA, dew: *mut L_DEWARP) -> l_int32;
}
extern "C" {
    pub fn dewarpaGetDewarp(dewa: *mut L_DEWARPA, index: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpaSetCurvatures(
        dewa: *mut L_DEWARPA,
        max_linecurv: l_int32,
        min_diff_linecurv: l_int32,
        max_diff_linecurv: l_int32,
        max_edgecurv: l_int32,
        max_diff_edgecurv: l_int32,
        max_edgeslope: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaUseBothArrays(dewa: *mut L_DEWARPA, useboth: l_int32) -> l_int32;
}
extern "C" {
    pub fn dewarpaSetCheckColumns(dewa: *mut L_DEWARPA, check_columns: l_int32) -> l_int32;
}
extern "C" {
    pub fn dewarpaSetMaxDistance(dewa: *mut L_DEWARPA, maxdist: l_int32) -> l_int32;
}
extern "C" {
    pub fn dewarpRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadStream(fp: *mut FILE) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadMem(data: *const l_uint8, size: usize) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpWrite(filename: *const ::std::os::raw::c_char, dew: *mut L_DEWARP) -> l_int32;
}
extern "C" {
    pub fn dewarpWriteStream(fp: *mut FILE, dew: *mut L_DEWARP) -> l_int32;
}
extern "C" {
    pub fn dewarpWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        dew: *mut L_DEWARP,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadStream(fp: *mut FILE) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadMem(data: *const l_uint8, size: usize) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaWrite(filename: *const ::std::os::raw::c_char, dewa: *mut L_DEWARPA) -> l_int32;
}
extern "C" {
    pub fn dewarpaWriteStream(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_int32;
}
extern "C" {
    pub fn dewarpaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        dewa: *mut L_DEWARPA,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpBuildPageModel(
        dew: *mut L_DEWARP,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpFindVertDisparity(
        dew: *mut L_DEWARP,
        ptaa: *mut PTAA,
        rotflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpFindHorizDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn dewarpGetTextlineCenters(pixs: *mut PIX, debugflag: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpRemoveShortLines(
        pixs: *mut PIX,
        ptaas: *mut PTAA,
        fract: l_float32,
        debugflag: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpFindHorizSlopeDisparity(
        dew: *mut L_DEWARP,
        pixb: *mut PIX,
        fractthresh: l_float32,
        parity: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpBuildLineModel(
        dew: *mut L_DEWARP,
        opensize: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaModelStatus(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pvsuccess: *mut l_int32,
        phsuccess: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaApplyDisparity(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        grayin: l_int32,
        x: l_int32,
        y: l_int32,
        ppixd: *mut *mut PIX,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaApplyDisparityBoxa(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        mapdir: l_int32,
        x: l_int32,
        y: l_int32,
        pboxad: *mut *mut BOXA,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpMinimize(dew: *mut L_DEWARP) -> l_int32;
}
extern "C" {
    pub fn dewarpPopulateFullRes(
        dew: *mut L_DEWARP,
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpSinglePage(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixd: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpSinglePageInit(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixb: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpSinglePageRun(
        pixs: *mut PIX,
        pixb: *mut PIX,
        dewa: *mut L_DEWARPA,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaListPages(dewa: *mut L_DEWARPA) -> l_int32;
}
extern "C" {
    pub fn dewarpaSetValidModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32)
        -> l_int32;
}
extern "C" {
    pub fn dewarpaInsertRefModels(
        dewa: *mut L_DEWARPA,
        notests: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaStripRefModels(dewa: *mut L_DEWARPA) -> l_int32;
}
extern "C" {
    pub fn dewarpaRestoreModels(dewa: *mut L_DEWARPA) -> l_int32;
}
extern "C" {
    pub fn dewarpaInfo(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_int32;
}
extern "C" {
    pub fn dewarpaModelStats(
        dewa: *mut L_DEWARPA,
        pnnone: *mut l_int32,
        pnvsuccess: *mut l_int32,
        pnvvalid: *mut l_int32,
        pnhsuccess: *mut l_int32,
        pnhvalid: *mut l_int32,
        pnref: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpaShowArrays(
        dewa: *mut L_DEWARPA,
        scalefact: l_float32,
        first: l_int32,
        last: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpDebug(
        dew: *mut L_DEWARP,
        subdirs: *const ::std::os::raw::c_char,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dewarpShowResults(
        dewa: *mut L_DEWARPA,
        sa: *mut SARRAY,
        boxa: *mut BOXA,
        firstpage: l_int32,
        lastpage: l_int32,
        pdfout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaCreate(n: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromDArray(
        darray: *mut l_float64,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaMakeSequence(
        startval: l_float64,
        increment: l_float64,
        size: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaDestroy(pda: *mut *mut L_DNA);
}
extern "C" {
    pub fn l_dnaCopy(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaClone(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaEmpty(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaAddNumber(da: *mut L_DNA, val: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaInsertNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaRemoveNumber(da: *mut L_DNA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaReplaceNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaGetCount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetCount(da: *mut L_DNA, newcount: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaGetDValue(da: *mut L_DNA, index: l_int32, pval: *mut l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaGetIValue(da: *mut L_DNA, index: l_int32, pival: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetValue(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaShiftValue(da: *mut L_DNA, index: l_int32, diff: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaGetIArray(da: *mut L_DNA) -> *mut l_int32;
}
extern "C" {
    pub fn l_dnaGetDArray(da: *mut L_DNA, copyflag: l_int32) -> *mut l_float64;
}
extern "C" {
    pub fn l_dnaGetRefcount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaChangeRefcount(da: *mut L_DNA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaGetParameters(
        da: *mut L_DNA,
        pstartx: *mut l_float64,
        pdelx: *mut l_float64,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetParameters(da: *mut L_DNA, startx: l_float64, delx: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaCopyParameters(dad: *mut L_DNA, das: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadStream(fp: *mut FILE) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaWrite(filename: *const ::std::os::raw::c_char, da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaWriteStream(fp: *mut FILE, da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaCreate(n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaCreateFull(nptr: l_int32, n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaTruncate(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaDestroy(pdaa: *mut *mut L_DNAA);
}
extern "C" {
    pub fn l_dnaaAddDna(daa: *mut L_DNAA, da: *mut L_DNA, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDnaCount(daa: *mut L_DNAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetNumberCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDna(daa: *mut L_DNAA, index: l_int32, accessflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaaReplaceDna(daa: *mut L_DNAA, index: l_int32, da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetValue(
        daa: *mut L_DNAA,
        i: l_int32,
        j: l_int32,
        pval: *mut l_float64,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaaAddNumber(daa: *mut L_DNAA, index: l_int32, val: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadStream(fp: *mut FILE) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaWrite(filename: *const ::std::os::raw::c_char, daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaWriteStream(fp: *mut FILE, daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaJoin(dad: *mut L_DNA, das: *mut L_DNA, istart: l_int32, iend: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaFlattenToDna(daa: *mut L_DNAA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaConvertToNuma(da: *mut L_DNA) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToDna(na: *mut NUMA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaUnionByAset(da1: *mut L_DNA, da2: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaRemoveDupsByAset(das: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaIntersectionByAset(da1: *mut L_DNA, da2: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_asetCreateFromDna(da: *mut L_DNA) -> *mut L_ASET;
}
extern "C" {
    pub fn l_dnaDiffAdjValues(das: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashCreate(nbuckets: l_int32, initsize: l_int32) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn l_dnaHashDestroy(pdahash: *mut *mut L_DNAHASH);
}
extern "C" {
    pub fn l_dnaHashGetCount(dahash: *mut L_DNAHASH) -> l_int32;
}
extern "C" {
    pub fn l_dnaHashGetTotalCount(dahash: *mut L_DNAHASH) -> l_int32;
}
extern "C" {
    pub fn l_dnaHashGetDna(dahash: *mut L_DNAHASH, key: l_uint64, copyflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashAdd(dahash: *mut L_DNAHASH, key: l_uint64, value: l_float64) -> l_int32;
}
extern "C" {
    pub fn l_dnaHashCreateFromDna(da: *mut L_DNA) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn l_dnaRemoveDupsByHash(
        das: *mut L_DNA,
        pdad: *mut *mut L_DNA,
        pdahash: *mut *mut L_DNAHASH,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaMakeHistoByHash(
        das: *mut L_DNA,
        pdahash: *mut *mut L_DNAHASH,
        pdav: *mut *mut L_DNA,
        pdac: *mut *mut L_DNA,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaIntersectionByHash(da1: *mut L_DNA, da2: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaFindValByHash(
        da: *mut L_DNA,
        dahash: *mut L_DNAHASH,
        val: l_float64,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphDwa_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_2(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSobelEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTwoSidedEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureEdgeSmoothness(
        pixs: *mut PIX,
        side: l_int32,
        minjump: l_int32,
        minreversal: l_int32,
        pjpl: *mut l_float32,
        pjspl: *mut l_float32,
        prpl: *mut l_float32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetEdgeProfile(
        pixs: *mut PIX,
        side: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetLastOffPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetLastOnPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn encodeBase64(
        inarray: *mut l_uint8,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeBase64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85(
        inarray: *mut l_uint8,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85(
        inarray: *mut ::std::os::raw::c_char,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn reformatPacked64(
        inarray: *mut ::std::os::raw::c_char,
        insize: l_int32,
        leadspace: l_int32,
        linechars: l_int32,
        addquotes: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixGammaTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCWithAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaGammaTRC(gamma: l_float32, minval: l_int32, maxval: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixContrastTRC(pixd: *mut PIX, pixs: *mut PIX, factor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaContrastTRC(factor: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn pixEqualizeTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        fract: l_float32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaEqualizeTRC(pix: *mut PIX, fract: l_float32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTRCMap(pixs: *mut PIX, pixm: *mut PIX, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixUnsharpMasking(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGrayFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray1D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray2D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixModifyHue(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixModifySaturation(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureSaturation(pixs: *mut PIX, factor: l_int32, psat: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixModifyBrightness(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMosaicColorShiftRGB(
        pixs: *mut PIX,
        roff: l_float32,
        goff: l_float32,
        boff: l_float32,
        delta: l_float32,
        nincr: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorShiftRGB(
        pixs: *mut PIX,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultConstantColor(
        pixs: *mut PIX,
        rfact: l_float32,
        gfact: l_float32,
        bfact: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultMatrixColor(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHalfEdgeByBandpass(
        pixs: *mut PIX,
        sm1h: l_int32,
        sm1v: l_int32,
        sm2h: l_int32,
        sm2v: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn fhmtautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn fhmtautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixHMTDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFHMTGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixItalicWords(
        pixs: *mut PIX,
        boxaw: *mut BOXA,
        pixw: *mut PIX,
        pboxa: *mut *mut BOXA,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixOrientCorrect(
        pixs: *mut PIX,
        minupconf: l_float32,
        minratio: l_float32,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        protation: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOrientDetect(
        pixs: *mut PIX,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn makeOrientDecision(
        upconf: l_float32,
        leftconf: l_float32,
        minupconf: l_float32,
        minratio: l_float32,
        porient: *mut l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUpDownDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUpDownDetectGeneral(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        npixels: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixOrientDetectDwa(
        pixs: *mut PIX,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUpDownDetectDwa(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUpDownDetectGeneralDwa(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        npixels: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirrorDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirrorDetectDwa(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFlipFHMTGen(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn fmorphautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn fmorphautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixCreate(width: l_int32, height: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCreateTemplate(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixClone(fpix: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCopy(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixResizeImageData(fpixd: *mut FPIX, fpixs: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixDestroy(pfpix: *mut *mut FPIX);
}
extern "C" {
    pub fn fpixGetDimensions(fpix: *mut FPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixSetDimensions(fpix: *mut FPIX, w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixGetWpl(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixSetWpl(fpix: *mut FPIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixGetRefcount(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixChangeRefcount(fpix: *mut FPIX, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixGetResolution(fpix: *mut FPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixSetResolution(fpix: *mut FPIX, xres: l_int32, yres: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixCopyResolution(fpixd: *mut FPIX, fpixs: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixGetData(fpix: *mut FPIX) -> *mut l_float32;
}
extern "C" {
    pub fn fpixSetData(fpix: *mut FPIX, data: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn fpixGetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, pval: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn fpixSetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn fpixaCreate(n: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaCopy(fpixa: *mut FPIXA, copyflag: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaDestroy(pfpixa: *mut *mut FPIXA);
}
extern "C" {
    pub fn fpixaAddFPix(fpixa: *mut FPIXA, fpix: *mut FPIX, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaGetCount(fpixa: *mut FPIXA) -> l_int32;
}
extern "C" {
    pub fn fpixaChangeRefcount(fpixa: *mut FPIXA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaGetFPix(fpixa: *mut FPIXA, index: l_int32, accesstype: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixaGetFPixDimensions(
        fpixa: *mut FPIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixaGetData(fpixa: *mut FPIXA, index: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn fpixaGetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixaSetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        val: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn dpixCreate(width: l_int32, height: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCreateTemplate(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixClone(dpix: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCopy(dpixd: *mut DPIX, dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixResizeImageData(dpixd: *mut DPIX, dpixs: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixDestroy(pdpix: *mut *mut DPIX);
}
extern "C" {
    pub fn dpixGetDimensions(dpix: *mut DPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn dpixSetDimensions(dpix: *mut DPIX, w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn dpixGetWpl(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixSetWpl(dpix: *mut DPIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn dpixGetRefcount(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixChangeRefcount(dpix: *mut DPIX, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn dpixGetResolution(dpix: *mut DPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn dpixSetResolution(dpix: *mut DPIX, xres: l_int32, yres: l_int32) -> l_int32;
}
extern "C" {
    pub fn dpixCopyResolution(dpixd: *mut DPIX, dpixs: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixGetData(dpix: *mut DPIX) -> *mut l_float64;
}
extern "C" {
    pub fn dpixSetData(dpix: *mut DPIX, data: *mut l_float64) -> l_int32;
}
extern "C" {
    pub fn dpixGetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, pval: *mut l_float64) -> l_int32;
}
extern "C" {
    pub fn dpixSetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, val: l_float64) -> l_int32;
}
extern "C" {
    pub fn fpixRead(filename: *const ::std::os::raw::c_char) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadStream(fp: *mut FILE) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadMem(data: *const l_uint8, size: usize) -> *mut FPIX;
}
extern "C" {
    pub fn fpixWrite(filename: *const ::std::os::raw::c_char, fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixWriteStream(fp: *mut FILE, fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixEndianByteSwap(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn dpixRead(filename: *const ::std::os::raw::c_char) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadStream(fp: *mut FILE) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadMem(data: *const l_uint8, size: usize) -> *mut DPIX;
}
extern "C" {
    pub fn dpixWrite(filename: *const ::std::os::raw::c_char, dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixWriteStream(fp: *mut FILE, dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixEndianByteSwap(dpixd: *mut DPIX, dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn fpixPrintStream(fp: *mut FILE, fpix: *mut FPIX, factor: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixConvertToFPix(pixs: *mut PIX, ncomps: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvertToDPix(pixs: *mut PIX, ncomps: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixConvertToPix(
        fpixs: *mut FPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixDisplayMaxDynamicRange(fpixs: *mut FPIX) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvertToDPix(fpix: *mut FPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixConvertToPix(
        dpixs: *mut DPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn dpixConvertToFPix(dpix: *mut DPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixGetMin(
        fpix: *mut FPIX,
        pminval: *mut l_float32,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixGetMax(
        fpix: *mut FPIX,
        pmaxval: *mut l_float32,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dpixGetMin(
        dpix: *mut DPIX,
        pminval: *mut l_float64,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn dpixGetMax(
        dpix: *mut DPIX,
        pmaxval: *mut l_float64,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixScaleByInteger(fpixs: *mut FPIX, factor: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn dpixScaleByInteger(dpixs: *mut DPIX, factor: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixLinearCombination(
        fpixd: *mut FPIX,
        fpixs1: *mut FPIX,
        fpixs2: *mut FPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMultConstant(fpix: *mut FPIX, addc: l_float32, multc: l_float32) -> l_int32;
}
extern "C" {
    pub fn dpixLinearCombination(
        dpixd: *mut DPIX,
        dpixs1: *mut DPIX,
        dpixs2: *mut DPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut DPIX;
}
extern "C" {
    pub fn dpixAddMultConstant(dpix: *mut DPIX, addc: l_float64, multc: l_float64) -> l_int32;
}
extern "C" {
    pub fn fpixSetAllArbitrary(fpix: *mut FPIX, inval: l_float32) -> l_int32;
}
extern "C" {
    pub fn dpixSetAllArbitrary(dpix: *mut DPIX, inval: l_float64) -> l_int32;
}
extern "C" {
    pub fn fpixAddBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRemoveBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMirroredBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddContinuedBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddSlopeBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRasterop(
        fpixd: *mut FPIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        fpixs: *mut FPIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixRotateOrth(fpixs: *mut FPIX, quads: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate180(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate90(fpixs: *mut FPIX, direction: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipLR(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipTB(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffinePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffine(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjectivePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjective(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn linearInterpolatePixelFloat(
        datas: *mut l_float32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        inval: l_float32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixThresholdToPix(fpix: *mut FPIX, thresh: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixComponentFunction(
        pix: *mut PIX,
        rnum: l_float32,
        gnum: l_float32,
        bnum: l_float32,
        rdenom: l_float32,
        gdenom: l_float32,
        bdenom: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixReadStreamGif(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemGif(cdata: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamGif(fp: *mut FILE, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemGif(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn gplotCreate(
        rootname: *const ::std::os::raw::c_char,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotDestroy(pgplot: *mut *mut GPLOT);
}
extern "C" {
    pub fn gplotAddPlot(
        gplot: *mut GPLOT,
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        plottitle: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotSetScaling(gplot: *mut GPLOT, scaling: l_int32) -> l_int32;
}
extern "C" {
    pub fn gplotMakeOutput(gplot: *mut GPLOT) -> l_int32;
}
extern "C" {
    pub fn gplotGenCommandFile(gplot: *mut GPLOT) -> l_int32;
}
extern "C" {
    pub fn gplotGenDataFiles(gplot: *mut GPLOT) -> l_int32;
}
extern "C" {
    pub fn gplotSimple1(
        na: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotSimple2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotSimpleN(
        naa: *mut NUMAA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotSimpleXY1(
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotSimpleXY2(
        nax: *mut NUMA,
        nay1: *mut NUMA,
        nay2: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotSimpleXYN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn gplotRead(filename: *const ::std::os::raw::c_char) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotWrite(filename: *const ::std::os::raw::c_char, gplot: *mut GPLOT) -> l_int32;
}
extern "C" {
    pub fn generatePtaLine(x1: l_int32, y1: l_int32, x2: l_int32, y2: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaWideLine(
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBox(box_: *mut BOX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBoxa(boxa: *mut BOXA, width: l_int32, removedups: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBox(
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaaBoxa(boxa: *mut BOXA) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaPolyline(
        ptas: *mut PTA,
        width: l_int32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaGrid(
        w: l_int32,
        h: l_int32,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn convertPtaLineTo4cc(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledCircle(radius: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledSquare(side: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaLineFromPt(
        x: l_int32,
        y: l_int32,
        length: l_float64,
        radang: l_float64,
    ) -> *mut PTA;
}
extern "C" {
    pub fn locatePtRadially(
        xr: l_int32,
        yr: l_int32,
        dist: l_float64,
        radang: l_float64,
        px: *mut l_float64,
        py: *mut l_float64,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderPlotFromNuma(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
        color: l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn makePlotPtaFromNuma(
        na: *mut NUMA,
        size: l_int32,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPlotFromNumaGen(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
        color: l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn makePlotPtaFromNumaGen(
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPta(pix: *mut PIX, pta: *mut PTA, op: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixRenderPtaArb(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderPtaBlend(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        op: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderLineArb(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderLineBlend(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderBox(pix: *mut PIX, box_: *mut BOX, width: l_int32, op: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixRenderBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderBoxa(pix: *mut PIX, boxa: *mut BOXA, width: l_int32, op: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixRenderBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        removedups: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashBox(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashMaskArb(
        pix: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashBoxa(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderHashBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderPolyline(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        op: l_int32,
        closeflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderPolylineArb(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        closeflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderPolylineBlend(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderGridArb(
        pix: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRenderRandomCmapPtaa(
        pix: *mut PIX,
        ptaa: *mut PTAA,
        polyflag: l_int32,
        width: l_int32,
        closeflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderPolygon(
        ptas: *mut PTA,
        width: l_int32,
        pxmin: *mut l_int32,
        pymin: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFillPolygon(pixs: *mut PIX, pta: *mut PTA, xmin: l_int32, ymin: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderContours(
        pixs: *mut PIX,
        startval: l_int32,
        incr: l_int32,
        outdepth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixAutoRenderContours(fpix: *mut FPIX, ncontours: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn fpixRenderContours(fpixs: *mut FPIX, incr: l_float32, proxim: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixGeneratePtaBoundary(pixs: *mut PIX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn pixErodeGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinary(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinarySpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdToBinary(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn thresholdToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        lines: *mut l_uint32,
        d: l_int32,
        thresh: l_int32,
    );
}
extern "C" {
    pub fn pixVarThresholdToBinary(pixs: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinary(pixs: *mut PIX, pixm: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinaryGen(
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByValue(pixs: *mut PIX, val: l_int32, usecmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByBand(
        pixs: *mut PIX,
        lower: l_int32,
        upper: l_int32,
        inband: l_int32,
        usecmap: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bpp(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bppSpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo2bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo4bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdOn8bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdGrayArb(
        pixs: *mut PIX,
        edgevals: *const ::std::os::raw::c_char,
        outdepth: l_int32,
        use_average: l_int32,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeGrayQuantIndexTable(nlevels: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn makeGrayQuantTableArb(
        na: *mut NUMA,
        outdepth: l_int32,
        ptab: *mut *mut l_int32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGenerateMaskByBand32(
        pixs: *mut PIX,
        refval: l_uint32,
        delm: l_int32,
        delp: l_int32,
        fractm: l_float32,
        fractp: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByDiscr32(
        pixs: *mut PIX,
        refval1: l_uint32,
        refval2: l_uint32,
        distflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromHisto(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        minfract: l_float32,
        maxsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromCmap(pixs: *mut PIX, cmap: *mut PIXCMAP, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn lheapCreate(nalloc: l_int32, direction: l_int32) -> *mut L_HEAP;
}
extern "C" {
    pub fn lheapDestroy(plh: *mut *mut L_HEAP, freeflag: l_int32);
}
extern "C" {
    pub fn lheapAdd(lh: *mut L_HEAP, item: *mut ::std::os::raw::c_void) -> l_int32;
}
extern "C" {
    pub fn lheapRemove(lh: *mut L_HEAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapGetCount(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapSwapUp(lh: *mut L_HEAP, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn lheapSwapDown(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapSort(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapSortStrictOrder(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapPrint(fp: *mut FILE, lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn jbRankHausInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        size: l_int32,
        rank: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInitWithoutComponents(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbAddPages(classer: *mut JBCLASSER, safiles: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn jbAddPage(classer: *mut JBCLASSER, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn jbAddPageComponents(
        classer: *mut JBCLASSER,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn jbClassifyRankHaus(
        classer: *mut JBCLASSER,
        boxa: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRankHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        area1: l_int32,
        area3: l_int32,
        rank: l_float32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbClassifyCorrelation(
        classer: *mut JBCLASSER,
        boxa: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn jbGetComponents(
        pixs: *mut PIX,
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWordMaskByDilation(
        pixs: *mut PIX,
        ppixm: *mut *mut PIX,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWordBoxesByDilation(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxa: *mut *mut BOXA,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn jbAccumulateComposites(
        pixaa: *mut PIXAA,
        pna: *mut *mut NUMA,
        pptat: *mut *mut PTA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn jbTemplatesFromComposites(pixac: *mut PIXA, na: *mut NUMA) -> *mut PIXA;
}
extern "C" {
    pub fn jbClasserCreate(method: l_int32, components: l_int32) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbClasserDestroy(pclasser: *mut *mut JBCLASSER);
}
extern "C" {
    pub fn jbDataSave(classer: *mut JBCLASSER) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataDestroy(pdata: *mut *mut JBDATA);
}
extern "C" {
    pub fn jbDataWrite(rootout: *const ::std::os::raw::c_char, jbdata: *mut JBDATA) -> l_int32;
}
extern "C" {
    pub fn jbDataRead(rootname: *const ::std::os::raw::c_char) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataRender(data: *mut JBDATA, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn jbGetULCorners(classer: *mut JBCLASSER, pixs: *mut PIX, boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn jbGetLLCorners(classer: *mut JBCLASSER) -> l_int32;
}
extern "C" {
    pub fn readHeaderJp2k(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn readHeaderMemJp2k(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fgetJp2kResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixReadJp2k(
        filename: *const ::std::os::raw::c_char,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJp2k(
        fp: *mut FILE,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteJp2k(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamJp2k(
        fp: *mut FILE,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadMemJp2k(
        data: *const l_uint8,
        size: usize,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemJp2k(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadJpeg(
        filename: *const ::std::os::raw::c_char,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJpeg(
        fp: *mut FILE,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderJpeg(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fgetJpegResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fgetJpegComment(fp: *mut FILE, pcomment: *mut *mut l_uint8) -> l_int32;
}
extern "C" {
    pub fn pixWriteJpeg(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamJpeg(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadMemJpeg(
        data: *const l_uint8,
        size: usize,
        cmflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemJpeg(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemJpeg(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetChromaSampling(pix: *mut PIX, sampling: l_int32) -> l_int32;
}
extern "C" {
    pub fn kernelCreate(height: l_int32, width: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDestroy(pkel: *mut *mut L_KERNEL);
}
extern "C" {
    pub fn kernelCopy(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelGetElement(
        kel: *mut L_KERNEL,
        row: l_int32,
        col: l_int32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn kernelSetElement(
        kel: *mut L_KERNEL,
        row: l_int32,
        col: l_int32,
        val: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn kernelGetParameters(
        kel: *mut L_KERNEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn kernelSetOrigin(kel: *mut L_KERNEL, cy: l_int32, cx: l_int32) -> l_int32;
}
extern "C" {
    pub fn kernelGetSum(kel: *mut L_KERNEL, psum: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn kernelGetMinMax(
        kel: *mut L_KERNEL,
        pmin: *mut l_float32,
        pmax: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn kernelNormalize(kels: *mut L_KERNEL, normsum: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelInvert(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn create2dFloatArray(sy: l_int32, sx: l_int32) -> *mut *mut l_float32;
}
extern "C" {
    pub fn kernelRead(fname: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelReadStream(fp: *mut FILE) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelWrite(fname: *const ::std::os::raw::c_char, kel: *mut L_KERNEL) -> l_int32;
}
extern "C" {
    pub fn kernelWriteStream(fp: *mut FILE, kel: *mut L_KERNEL) -> l_int32;
}
extern "C" {
    pub fn kernelCreateFromString(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        kdata: *const ::std::os::raw::c_char,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromPix(pix: *mut PIX, cy: l_int32, cx: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDisplayInPix(kel: *mut L_KERNEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn parseStringForNumbers(
        str: *const ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn makeFlatKernel(
        height: l_int32,
        width: l_int32,
        cy: l_int32,
        cx: l_int32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernel(
        halfheight: l_int32,
        halfwidth: l_int32,
        stdev: l_float32,
        max: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernelSep(
        halfheight: l_int32,
        halfwidth: l_int32,
        stdev: l_float32,
        max: l_float32,
        pkelx: *mut *mut L_KERNEL,
        pkely: *mut *mut L_KERNEL,
    ) -> l_int32;
}
extern "C" {
    pub fn makeDoGKernel(
        halfheight: l_int32,
        halfwidth: l_int32,
        stdev: l_float32,
        ratio: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn getImagelibVersions() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn listDestroy(phead: *mut *mut DLLIST);
}
extern "C" {
    pub fn listAddToHead(phead: *mut *mut DLLIST, data: *mut ::std::os::raw::c_void) -> l_int32;
}
extern "C" {
    pub fn listAddToTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_int32;
}
extern "C" {
    pub fn listInsertBefore(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_int32;
}
extern "C" {
    pub fn listInsertAfter(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_int32;
}
extern "C" {
    pub fn listRemoveElement(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromHead(phead: *mut *mut DLLIST) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listFindElement(head: *mut DLLIST, data: *mut ::std::os::raw::c_void) -> *mut DLLIST;
}
extern "C" {
    pub fn listFindTail(head: *mut DLLIST) -> *mut DLLIST;
}
extern "C" {
    pub fn listGetCount(head: *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn listReverse(phead: *mut *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn listJoin(phead1: *mut *mut DLLIST, phead2: *mut *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn l_amapCreate(keytype: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn l_amapFind(m: *mut L_AMAP, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_amapInsert(m: *mut L_AMAP, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_amapDelete(m: *mut L_AMAP, key: RB_TYPE);
}
extern "C" {
    pub fn l_amapDestroy(pm: *mut *mut L_AMAP);
}
extern "C" {
    pub fn l_amapGetFirst(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetNext(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetLast(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetPrev(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapSize(m: *mut L_AMAP) -> l_int32;
}
extern "C" {
    pub fn l_asetCreate(keytype: l_int32) -> *mut L_ASET;
}
extern "C" {
    pub fn l_asetFind(s: *mut L_ASET, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_asetInsert(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDelete(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDestroy(ps: *mut *mut L_ASET);
}
extern "C" {
    pub fn l_asetGetFirst(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetNext(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetLast(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetPrev(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetSize(s: *mut L_ASET) -> l_int32;
}
extern "C" {
    pub fn generateBinaryMaze(
        w: l_int32,
        h: l_int32,
        xi: l_int32,
        yi: l_int32,
        wallps: l_float32,
        ranis: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSearchBinaryMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixSearchGrayMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDilate(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixErode(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHMT(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpen(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixClose(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafe(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrick(pixd: *mut PIX, pixs: *mut PIX, hsize: l_int32, vsize: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selectComposableSels(
        size: l_int32,
        direction: l_int32,
        psel1: *mut *mut SEL,
        psel2: *mut *mut SEL,
    ) -> l_int32;
}
extern "C" {
    pub fn selectComposableSizes(
        size: l_int32,
        pfactor1: *mut l_int32,
        pfactor2: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDilateCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getMorphBorderPixelColor(type_: l_int32, depth: l_int32) -> l_uint32;
}
extern "C" {
    pub fn pixExtractBoundary(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceByComponent(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByComponent(
        pixas: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixMorphSequenceByRegion(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByRegion(
        pixs: *mut PIX,
        pixam: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixUnionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixIntersectionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectiveConnCompFill(
        pixs: *mut PIX,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        dsize: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        color: l_uint32,
        scale: l_float32,
        nlevels: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtendByMorph(
        pixas: *mut PIXA,
        type_: l_int32,
        niters: l_int32,
        sel: *mut SEL,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaExtendByScaling(
        pixas: *mut PIXA,
        nasc: *mut NUMA,
        type_: l_int32,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSeedfillMorph(
        pixs: *mut PIX,
        pixm: *mut PIX,
        maxiters: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunHistogramMorph(
        pixs: *mut PIX,
        runtype: l_int32,
        direction: l_int32,
        maxsize: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixTophat(pixs: *mut PIX, hsize: l_int32, vsize: l_int32, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixHDome(pixs: *mut PIX, height: l_int32, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFastTophat(
        pixs: *mut PIX,
        xsize: l_int32,
        ysize: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphGradient(
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
        smoothing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaCentroids(pixa: *mut PIXA) -> *mut PTA;
}
extern "C" {
    pub fn pixCentroid(
        pix: *mut PIX,
        centtab: *mut l_int32,
        sumtab: *mut l_int32,
        pxave: *mut l_float32,
        pyave: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDilateBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getExtendedCompositeParameters(
        size: l_int32,
        pn: *mut l_int32,
        pextra: *mut l_int32,
        pactualsize: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn morphSequenceVerify(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn pixGrayMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaCreate(n: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromFArray(
        farray: *mut l_float32,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromString(str: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaDestroy(pna: *mut *mut NUMA);
}
extern "C" {
    pub fn numaCopy(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaClone(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaEmpty(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaAddNumber(na: *mut NUMA, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaInsertNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaRemoveNumber(na: *mut NUMA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaReplaceNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaGetCount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSetCount(na: *mut NUMA, newcount: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetFValue(na: *mut NUMA, index: l_int32, pval: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn numaGetIValue(na: *mut NUMA, index: l_int32, pival: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaSetValue(na: *mut NUMA, index: l_int32, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaShiftValue(na: *mut NUMA, index: l_int32, diff: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaGetIArray(na: *mut NUMA) -> *mut l_int32;
}
extern "C" {
    pub fn numaGetFArray(na: *mut NUMA, copyflag: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn numaGetRefcount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaChangeRefcount(na: *mut NUMA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetParameters(
        na: *mut NUMA,
        pstartx: *mut l_float32,
        pdelx: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaSetParameters(na: *mut NUMA, startx: l_float32, delx: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaCopyParameters(nad: *mut NUMA, nas: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaConvertToSarray(
        na: *mut NUMA,
        size1: l_int32,
        size2: l_int32,
        addzeros: l_int32,
        type_: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn numaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadStream(fp: *mut FILE) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadMem(data: *const l_uint8, size: usize) -> *mut NUMA;
}
extern "C" {
    pub fn numaWrite(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaWriteStream(fp: *mut FILE, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaaCreate(n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCreateFull(nptr: l_int32, n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaTruncate(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaDestroy(pnaa: *mut *mut NUMAA);
}
extern "C" {
    pub fn numaaAddNuma(naa: *mut NUMAA, na: *mut NUMA, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaGetCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumaCount(naa: *mut NUMAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumberCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetPtrArray(naa: *mut NUMAA) -> *mut *mut NUMA;
}
extern "C" {
    pub fn numaaGetNuma(naa: *mut NUMAA, index: l_int32, accessflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaaReplaceNuma(naa: *mut NUMAA, index: l_int32, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaaGetValue(
        naa: *mut NUMAA,
        i: l_int32,
        j: l_int32,
        pfval: *mut l_float32,
        pival: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaaAddNumber(naa: *mut NUMAA, index: l_int32, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadStream(fp: *mut FILE) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadMem(data: *const l_uint8, size: usize) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaWrite(filename: *const ::std::os::raw::c_char, naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaWriteStream(fp: *mut FILE, naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaArithOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaLogicalOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaInvert(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimilar(
        na1: *mut NUMA,
        na2: *mut NUMA,
        maxdiff: l_float32,
        psimilar: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaAddToNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn numaGetMin(na: *mut NUMA, pminval: *mut l_float32, piminloc: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetMax(na: *mut NUMA, pmaxval: *mut l_float32, pimaxloc: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetSum(na: *mut NUMA, psum: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn numaGetPartialSums(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSumOnInterval(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        psum: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaHasOnlyIntegers(
        na: *mut NUMA,
        maxsamples: l_int32,
        pallints: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaSubsample(nas: *mut NUMA, subfactor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeDelta(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeSequence(startval: l_float32, increment: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeConstant(val: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeAbsValue(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        val: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSpecifiedBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRemoveBorder(nas: *mut NUMA, left: l_int32, right: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCountNonzeroRuns(na: *mut NUMA, pcount: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetNonzeroRange(
        na: *mut NUMA,
        eps: l_float32,
        pfirst: *mut l_int32,
        plast: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetCountRelativeToZero(
        na: *mut NUMA,
        type_: l_int32,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaClipToInterval(nas: *mut NUMA, first: l_int32, last: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeThresholdIndicator(
        nas: *mut NUMA,
        thresh: l_float32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaUniformSampling(nas: *mut NUMA, nsamp: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaReverse(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaLowPassIntervals(nas: *mut NUMA, thresh: l_float32, maxn: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaThresholdEdges(
        nas: *mut NUMA,
        thresh1: l_float32,
        thresh2: l_float32,
        maxn: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSpanValues(
        na: *mut NUMA,
        span: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetEdgeValues(
        na: *mut NUMA,
        edge: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
        psign: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateEqxVal(
        startx: l_float32,
        deltax: l_float32,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateArbxVal(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateEqxInterval(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateArbxInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaFitMax(
        na: *mut NUMA,
        pmaxval: *mut l_float32,
        naloc: *mut NUMA,
        pmaxloc: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaDifferentiateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaIntegrateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        psum: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaSortGeneral(
        na: *mut NUMA,
        pnasort: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        pnainvert: *mut *mut NUMA,
        sortorder: l_int32,
        sorttype: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaSortAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortIndexAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaChooseSortType(nas: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSort(naout: *mut NUMA, nain: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaBinSort(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSortIndex(na: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetBinSortIndex(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortByIndex(nas: *mut NUMA, naindex: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaIsSorted(nas: *mut NUMA, sortorder: l_int32, psorted: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaSortPair(
        nax: *mut NUMA,
        nay: *mut NUMA,
        sortorder: l_int32,
        pnasx: *mut *mut NUMA,
        pnasy: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInvertMap(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaPseudorandomSequence(size: l_int32, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaRandomPermutation(nas: *mut NUMA, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetRankValue(
        na: *mut NUMA,
        fract: l_float32,
        nasort: *mut NUMA,
        usebins: l_int32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetMedian(na: *mut NUMA, pval: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn numaGetBinnedMedian(na: *mut NUMA, pval: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetMode(na: *mut NUMA, pval: *mut l_float32, pcount: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaGetMedianVariation(
        na: *mut NUMA,
        pmedval: *mut l_float32,
        pmedvar: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaJoin(nad: *mut NUMA, nas: *mut NUMA, istart: l_int32, iend: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaJoin(naad: *mut NUMAA, naas: *mut NUMAA, istart: l_int32, iend: l_int32)
        -> l_int32;
}
extern "C" {
    pub fn numaaFlattenToNuma(naa: *mut NUMAA) -> *mut NUMA;
}
extern "C" {
    pub fn numaErode(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaDilate(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaOpen(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaClose(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaTransform(nas: *mut NUMA, shift: l_float32, scale: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimpleStats(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        pmean: *mut l_float32,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaWindowedStats(
        nas: *mut NUMA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaWindowedMean(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedMeanSquare(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedVariance(
        nam: *mut NUMA,
        nams: *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaWindowedMedian(nas: *mut NUMA, halfwin: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToInt(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pbinsize: *mut l_int32,
        pbinstart: *mut l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramAuto(na: *mut NUMA, maxbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramClipped(
        na: *mut NUMA,
        binsize: l_float32,
        maxsize: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRebinHistogram(nas: *mut NUMA, newsize: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaNormalizeHistogram(nas: *mut NUMA, tsum: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetStatsUsingHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pmin: *mut l_float32,
        pmax: *mut l_float32,
        pmean: *mut l_float32,
        pvariance: *mut l_float32,
        pmedian: *mut l_float32,
        rank: l_float32,
        prval: *mut l_float32,
        phisto: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetHistogramStats(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetHistogramStatsOnInterval(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        ifirst: l_int32,
        ilast: l_int32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaMakeRankFromHistogram(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaHistogramGetRankFromVal(
        na: *mut NUMA,
        rval: l_float32,
        prank: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaHistogramGetValFromRank(
        na: *mut NUMA,
        rank: l_float32,
        prval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaDiscretizeRankAndIntensity(
        na: *mut NUMA,
        nbins: l_int32,
        pnarbin: *mut *mut NUMA,
        pnam: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnabb: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetRankBinValues(
        na: *mut NUMA,
        nbins: l_int32,
        pnarbin: *mut *mut NUMA,
        pnam: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaSplitDistribution(
        na: *mut NUMA,
        scorefract: l_float32,
        psplitindex: *mut l_int32,
        pave1: *mut l_float32,
        pave2: *mut l_float32,
        pnum1: *mut l_float32,
        pnum2: *mut l_float32,
        pnascore: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn grayHistogramsToEMD(naa1: *mut NUMAA, naa2: *mut NUMAA, pnad: *mut *mut NUMA)
        -> l_int32;
}
extern "C" {
    pub fn numaEarthMoverDistance(na1: *mut NUMA, na2: *mut NUMA, pdist: *mut l_float32)
        -> l_int32;
}
extern "C" {
    pub fn grayInterHistogramStats(
        naa: *mut NUMAA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn numaFindPeaks(
        nas: *mut NUMA,
        nmax: l_int32,
        fract1: l_float32,
        fract2: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindExtrema(nas: *mut NUMA, delta: l_float32, pnav: *mut *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaCountReversals(
        nas: *mut NUMA,
        minreversal: l_float32,
        pnr: *mut l_int32,
        pnrpl: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaSelectCrossingThreshold(
        nax: *mut NUMA,
        nay: *mut NUMA,
        estthresh: l_float32,
        pbestthresh: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaCrossingsByThreshold(nax: *mut NUMA, nay: *mut NUMA, thresh: l_float32)
        -> *mut NUMA;
}
extern "C" {
    pub fn numaCrossingsByPeaks(nax: *mut NUMA, nay: *mut NUMA, delta: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaEvalBestHaarParameters(
        nas: *mut NUMA,
        relweight: l_float32,
        nwidth: l_int32,
        nshift: l_int32,
        minwidth: l_float32,
        maxwidth: l_float32,
        pbestwidth: *mut l_float32,
        pbestshift: *mut l_float32,
        pbestscore: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaEvalHaarSum(
        nas: *mut NUMA,
        width: l_float32,
        shift: l_float32,
        relweight: l_float32,
        pscore: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn genConstrainedNumaInRange(
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRegionsBinary(
        pixs: *mut PIX,
        ppixhm: *mut *mut PIX,
        ppixtm: *mut *mut PIX,
        ppixtb: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGenHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextlineMask(
        pixs: *mut PIX,
        ppixvws: *mut *mut PIX,
        ptlfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextblockMask(pixs: *mut PIX, pixvws: *mut PIX, pixadb: *mut PIXA) -> *mut PIX;
}
extern "C" {
    pub fn pixFindPageForeground(
        pixs: *mut PIX,
        threshold: l_int32,
        mindist: l_int32,
        erasedist: l_int32,
        pagenum: l_int32,
        showmorph: l_int32,
        display: l_int32,
        pdfdir: *const ::std::os::raw::c_char,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSplitIntoCharacters(
        pixs: *mut PIX,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdebug: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSplitComponentWithProfile(
        pixs: *mut PIX,
        delta: l_int32,
        mindel: l_int32,
        ppixdebug: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixExtractTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        minw: l_int32,
        minh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixExtractRawTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixCountTextColumns(
        pixs: *mut PIX,
        deltafract: l_float32,
        peakfract: l_float32,
        clipfract: l_float32,
        pncols: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDecideIfText(
        pixs: *mut PIX,
        box_: *mut BOX,
        pistext: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindThreshFgExtent(
        pixs: *mut PIX,
        thresh: l_int32,
        ptop: *mut l_int32,
        pbot: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDecideIfTable(
        pixs: *mut PIX,
        box_: *mut BOX,
        orient: l_int32,
        pscore: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixPrepare1bpp(
        pixs: *mut PIX,
        box_: *mut BOX,
        cropfract: l_float32,
        outres: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEstimateBackground(
        pixs: *mut PIX,
        darkthresh: l_int32,
        edgecrop: l_float32,
        pbg: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindLargeRectangles(
        pixs: *mut PIX,
        polarity: l_int32,
        nrect: l_int32,
        pboxa: *mut *mut BOXA,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindLargestRectangle(
        pixs: *mut PIX,
        polarity: l_int32,
        pbox: *mut *mut BOX,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetSelectCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorGrayRegionsCmap(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorGrayCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColorGrayMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn addColorizedGrayToCmap(
        cmap: *mut PIXCMAP,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pna: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetSelectMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn parseForProtos(
        filein: *const ::std::os::raw::c_char,
        prestring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn boxaGetWhiteblocks(
        boxas: *mut BOXA,
        box_: *mut BOX,
        sortflag: l_int32,
        maxboxes: l_int32,
        maxoverlap: l_float32,
        maxperim: l_int32,
        fract: l_float32,
        maxpops: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPruneSortedOnOverlap(boxas: *mut BOXA, maxoverlap: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn convertFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn saConvertFilesToPdf(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn saConvertFilesToPdfData(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn selectDefaultPdfEncoding(pix: *mut PIX, ptype: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn convertUnscaledFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdf(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdfData(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn convertUnscaledToPdfData(
        fname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaConvertToPdf(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaConvertToPdfData(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn convertToPdf(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertImageDataToPdf(
        imdata: *mut l_uint8,
        size: usize,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertToPdfData(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertImageDataToPdfData(
        imdata: *mut l_uint8,
        size: usize,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvertToPdf(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamPdf(
        fp: *mut FILE,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemPdf(
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertSegmentedFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        baa: *mut BOXAA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertNumberedMasksToBoxaa(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn convertToPdfSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvertToPdfSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertToPdfDataSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvertToPdfDataSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn concatenatePdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn saConcatenatePdf(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn ptraConcatenatePdf(pa: *mut L_PTRA, fileout: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn concatenatePdfToData(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn saConcatenatePdfToData(
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvertToPdfData(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptraConcatenatePdfToData(
        pa_data: *mut L_PTRA,
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn convertTiffMultipageToPdf(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_generateCIDataForPdf(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_int32;
}
extern "C" {
    pub fn l_generateFlateDataPdf(
        fname: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateCIData(
        fname: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGenerateCIData(
        pixs: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_int32;
}
extern "C" {
    pub fn l_generateFlateData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateG4Data(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn cidConvertToPdfData(
        cid: *mut L_COMP_DATA,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn l_CIDataDestroy(pcid: *mut *mut L_COMP_DATA);
}
extern "C" {
    pub fn l_pdfSetG4ImageMask(flag: l_int32);
}
extern "C" {
    pub fn l_pdfSetDateAndVersion(flag: l_int32);
}
extern "C" {
    pub fn setPixMemoryManager(allocator: alloc_fn, deallocator: dealloc_fn);
}
extern "C" {
    pub fn pixCreate(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateNoInit(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplate(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplateNoInit(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateHeader(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixClone(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDestroy(ppix: *mut *mut PIX);
}
extern "C" {
    pub fn pixCopy(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeImageData(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixCopyColormap(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSizesEqual(pix1: *mut PIX, pix2: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixTransferAllData(
        pixd: *mut PIX,
        ppixs: *mut *mut PIX,
        copytext: l_int32,
        copyformat: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSwapAndDestroy(ppixd: *mut *mut PIX, ppixs: *mut *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetWidth(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWidth(pix: *mut PIX, width: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetHeight(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetHeight(pix: *mut PIX, height: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDepth(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetDepth(pix: *mut PIX, depth: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDimensions(
        pix: *mut PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetDimensions(pix: *mut PIX, w: l_int32, h: l_int32, d: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyDimensions(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetSpp(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpp(pix: *mut PIX, spp: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopySpp(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetWpl(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWpl(pix: *mut PIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRefcount(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixChangeRefcount(pix: *mut PIX, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetXRes(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetXRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetYRes(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetYRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetResolution(pix: *mut PIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSetResolution(pix: *mut PIX, xres: l_int32, yres: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyResolution(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixScaleResolution(pix: *mut PIX, xscale: l_float32, yscale: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixGetInputFormat(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetInputFormat(pix: *mut PIX, informat: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyInputFormat(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpecial(pix: *mut PIX, special: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetText(pix: *mut PIX) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixSetText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixAddText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixCopyText(pixd: *mut PIX, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetColormap(pix: *mut PIX) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixSetColormap(pix: *mut PIX, colormap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixDestroyColormap(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetData(pix: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixExtractData(pixs: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixFreeData(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetLinePtrs(pix: *mut PIX, psize: *mut l_int32) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixPrintStreamInfo(
        fp: *mut FILE,
        pix: *mut PIX,
        text: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetPixel(pix: *mut PIX, x: l_int32, y: l_int32, pval: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixSetPixel(pix: *mut PIX, x: l_int32, y: l_int32, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRandomPixel(
        pix: *mut PIX,
        pval: *mut l_uint32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixClearPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixFlipPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn setPixelLow(line: *mut l_uint32, x: l_int32, depth: l_int32, val: l_uint32);
}
extern "C" {
    pub fn pixGetBlackOrWhiteVal(pixs: *mut PIX, op: l_int32, pval: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixClearAll(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetAll(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetAllGray(pix: *mut PIX, grayval: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSetAllArbitrary(pix: *mut PIX, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixSetBlackOrWhite(pixs: *mut PIX, op: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSetComponentArbitrary(pix: *mut PIX, comp: l_int32, val: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixClearInRect(pix: *mut PIX, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn pixSetInRect(pix: *mut PIX, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn pixSetInRectArbitrary(pix: *mut PIX, box_: *mut BOX, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixBlendInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        val: l_uint32,
        fract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetPadBits(pix: *mut PIX, val: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSetPadBitsBand(pix: *mut PIX, by: l_int32, bh: l_int32, val: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSetOrClearBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetBorderVal(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetBorderRingVal(pixs: *mut PIX, dist: l_int32, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixSetMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCopyBorder(
        pixd: *mut PIX,
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorder(pixs: *mut PIX, npix: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBlackOrWhiteBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorder(pixs: *mut PIX, npix: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRepeatedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMixedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddContinuedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixShiftAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        shiftx: l_float32,
        shifty: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayLayersRGBA(pixs: *mut PIX, val: l_uint32, maxw: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateRGBImage(pixr: *mut PIX, pixg: *mut PIX, pixb: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBComponent(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBComponentCmap(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCopyRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_int32;
}
extern "C" {
    pub fn extractRGBValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractRGBAValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractMinMaxComponent(pixel: l_uint32, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBLine(
        pixs: *mut PIX,
        row: l_int32,
        bufr: *mut l_uint8,
        bufg: *mut l_uint8,
        bufb: *mut l_uint8,
    ) -> l_int32;
}
extern "C" {
    pub fn pixEndianByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianByteSwap(pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn lineEndianByteSwap(datad: *mut l_uint32, datas: *mut l_uint32, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixEndianTwoByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianTwoByteSwap(pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetRasterData(
        pixs: *mut PIX,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixAlphaIsOpaque(pix: *mut PIX, popaque: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSetupByteProcessing(
        pix: *mut PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut *mut l_uint8;
}
extern "C" {
    pub fn pixCleanupByteProcessing(pix: *mut PIX, lineptrs: *mut *mut l_uint8) -> l_int32;
}
extern "C" {
    pub fn l_setAlphaMaskBorder(val1: l_float32, val2: l_float32);
}
extern "C" {
    pub fn pixSetMasked(pixd: *mut PIX, pixm: *mut PIX, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixSetMaskedGeneral(
        pixd: *mut PIX,
        pixm: *mut PIX,
        val: l_uint32,
        x: l_int32,
        y: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCombineMasked(pixd: *mut PIX, pixs: *mut PIX, pixm: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixCombineMaskedGeneral(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixPaintThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        val: l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixPaintSelfThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        searchdir: l_int32,
        mindist: l_int32,
        tilesize: l_int32,
        ntiles: l_int32,
        distblend: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMakeMaskFromVal(pixs: *mut PIX, val: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeMaskFromLUT(pixs: *mut PIX, tab: *mut l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeArbMaskFromRGB(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetUnderTransparency(pixs: *mut PIX, val: l_uint32, debug: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeAlphaFromMask(pixs: *mut PIX, dist: l_int32, pbox: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetColorNearMaskBoundary(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pval: *mut l_uint32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixInvert(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixOr(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAnd(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixXor(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtract(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixZero(pix: *mut PIX, pempty: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixForegroundFraction(pix: *mut PIX, pfract: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixaCountPixels(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixels(pixs: *mut PIX, pcount: *mut l_int32, tab8: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCountPixelsInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCountByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByRow(pix: *mut PIX, tab8: *mut l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByColumn(pix: *mut PIX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsInRow(
        pix: *mut PIX,
        row: l_int32,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetMomentByColumn(pix: *mut PIX, order: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixThresholdPixelSum(
        pix: *mut PIX,
        thresh: l_int32,
        pabove: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn makePixelSumTab8() -> *mut l_int32;
}
extern "C" {
    pub fn makePixelCentroidTab8() -> *mut l_int32;
}
extern "C" {
    pub fn pixAverageByRow(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageByColumn(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageInRect(pix: *mut PIX, box_: *mut BOX, pave: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixVarianceByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceInRect(pix: *mut PIX, box_: *mut BOX, prootvar: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixAbsDiffByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffInRect(
        pix: *mut PIX,
        box_: *mut BOX,
        dir: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixAbsDiffOnLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCountArbInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        val: l_int32,
        factor: l_int32,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirroredTiling(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindRepCloseTile(
        pixs: *mut PIX,
        box_: *mut BOX,
        searchdir: l_int32,
        mindist: l_int32,
        tsize: l_int32,
        ntiles: l_int32,
        pboxtile: *mut *mut BOX,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetGrayHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramTiled(
        pixs: *mut PIX,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixGetColorHistogram(
        pixs: *mut PIX,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetColorHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetCmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountRGBColors(pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetColorAmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn pixGetRankValue(
        pixs: *mut PIX,
        factor: l_int32,
        rank: l_float32,
        pvalue: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRankValueMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRankValueMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        pval: *mut l_float32,
        pna: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetPixelAverage(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pval: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetPixelStats(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        pvalue: *mut l_uint32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetAverageMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetAverageMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetAverageTiledRGB(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetAverageTiled(pixs: *mut PIX, sx: l_int32, sy: l_int32, type_: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixRowStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColumnStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRangeValues(
        pixs: *mut PIX,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetExtremeValue(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        pgrayval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetMaxValueInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pmaxval: *mut l_uint32,
        pxmax: *mut l_int32,
        pymax: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetBinnedComponentRange(
        pixs: *mut PIX,
        nbins: l_int32,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pcarray: *mut *mut l_uint32,
        fontsize: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRankColorArray(
        pixs: *mut PIX,
        nbins: l_int32,
        type_: l_int32,
        factor: l_int32,
        pcarray: *mut *mut l_uint32,
        debugflag: l_int32,
        fontsize: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetBinnedColor(
        pixs: *mut PIX,
        pixg: *mut PIX,
        factor: l_int32,
        nbins: l_int32,
        nalut: *mut NUMA,
        pcarray: *mut *mut l_uint32,
        debugflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayColorArray(
        carray: *mut l_uint32,
        ncolors: l_int32,
        side: l_int32,
        ncols: l_int32,
        fontsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRankBinByStrip(
        pixs: *mut PIX,
        direction: l_int32,
        size: l_int32,
        nbins: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetAlignedStats(
        pixa: *mut PIXA,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtractColumnFromEachPix(pixa: *mut PIXA, col: l_int32, pixd: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetRowStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        colvect: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetColumnStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        rowvect: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetPixelColumn(pix: *mut PIX, col: l_int32, colvect: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixThresholdForFgBg(
        pixs: *mut PIX,
        factor: l_int32,
        thresh: l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSplitDistributionFgBg(
        pixs: *mut PIX,
        scorefract: l_float32,
        factor: l_int32,
        pthresh: *mut l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindDimensions(
        pixa: *mut PIXA,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindAreaPerimRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindPerimToAreaRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimToAreaRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindPerimSizeRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimSizeRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pratio: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindAreaFraction(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFraction(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindAreaFractionMasked(pixa: *mut PIXA, pixm: *mut PIX, debug: l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFractionMasked(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixm: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindWidthHeightRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixaFindWidthHeightProduct(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindOverlapFraction(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x2: l_int32,
        y2: l_int32,
        tab: *mut l_int32,
        pratio: *mut l_float32,
        pnoverlap: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindRectangleComps(
        pixs: *mut PIX,
        dist: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConformsToRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pconforms: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixClipRectangles(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixClipRectangle(pixs: *mut PIX, box_: *mut BOX, pboxc: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixClipMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        outval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCropToMatch(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        ppixd1: *mut *mut PIX,
        ppixd2: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCropToSize(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeToMatch(pixs: *mut PIX, pixt: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeFrameMask(
        w: l_int32,
        h: l_int32,
        hf1: l_float32,
        hf2: l_float32,
        vf1: l_float32,
        vf2: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFractionFgInMask(pix1: *mut PIX, pix2: *mut PIX, pfract: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixClipToForeground(
        pixs: *mut PIX,
        ppixd: *mut *mut PIX,
        pbox: *mut *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixTestClipToForeground(pixs: *mut PIX, pcanclip: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixClipBoxToForeground(
        pixs: *mut PIX,
        boxs: *mut BOX,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixScanForForeground(
        pixs: *mut PIX,
        box_: *mut BOX,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixClipBoxToEdges(
        pixs: *mut PIX,
        boxs: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixScanForEdge(
        pixs: *mut PIX,
        box_: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixExtractOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> l_float32;
}
extern "C" {
    pub fn pixAverageIntensityProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixReversalProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        minreversal: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixWindowedVarianceOnLine(
        pixs: *mut PIX,
        dir: l_int32,
        loc: l_int32,
        c1: l_int32,
        c2: l_int32,
        size: l_int32,
        pnad: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMinMaxNearLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        dist: l_int32,
        direction: l_int32,
        pnamin: *mut *mut NUMA,
        pnamax: *mut *mut NUMA,
        pminave: *mut l_float32,
        pmaxave: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRankRowTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRankColumnTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixaCreate(n: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromPix(
        pixs: *mut PIX,
        n: l_int32,
        cellw: l_int32,
        cellh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromBoxa(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        pcropwarn: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitPix(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaDestroy(ppixa: *mut *mut PIXA);
}
extern "C" {
    pub fn pixaCopy(pixa: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPix(pixa: *mut PIXA, pix: *mut PIX, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAddBox(pixa: *mut PIXA, box_: *mut BOX, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaExtendArrayToSize(pixa: *mut PIXA, size: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaGetCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaChangeRefcount(pixa: *mut PIXA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaGetPix(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetPixDimensions(
        pixa: *mut PIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaGetBoxa(pixa: *mut PIXA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaGetBoxaCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetBox(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixaGetBoxGeometry(
        pixa: *mut PIXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaSetBoxa(pixa: *mut PIXA, boxa: *mut BOXA, accesstype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaGetPixArray(pixa: *mut PIXA) -> *mut *mut PIX;
}
extern "C" {
    pub fn pixaVerifyDepth(pixa: *mut PIXA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaVerifyDimensions(
        pixa: *mut PIXA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaIsFull(pixa: *mut PIXA, pfullpa: *mut l_int32, pfullba: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaCountText(pixa: *mut PIXA, pntext: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaSetText(pixa: *mut PIXA, sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn pixaGetLinePtrs(
        pixa: *mut PIXA,
        psize: *mut l_int32,
    ) -> *mut *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixaWriteStreamInfo(fp: *mut FILE, pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaReplacePix(
        pixa: *mut PIXA,
        index: l_int32,
        pix: *mut PIX,
        box_: *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaInsertPix(
        pixa: *mut PIXA,
        index: l_int32,
        pixs: *mut PIX,
        box_: *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaRemovePix(pixa: *mut PIXA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaRemovePixAndSave(
        pixa: *mut PIXA,
        index: l_int32,
        ppix: *mut *mut PIX,
        pbox: *mut *mut BOX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaInitFull(pixa: *mut PIXA, pix: *mut PIX, box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn pixaClear(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaJoin(pixad: *mut PIXA, pixas: *mut PIXA, istart: l_int32, iend: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaInterleave(pixa1: *mut PIXA, pixa2: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaJoin(paad: *mut PIXAA, paas: *mut PIXAA, istart: l_int32, iend: l_int32)
        -> l_int32;
}
extern "C" {
    pub fn pixaaCreate(n: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaCreateFromPixa(
        pixa: *mut PIXA,
        n: l_int32,
        type_: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaDestroy(ppaa: *mut *mut PIXAA);
}
extern "C" {
    pub fn pixaaAddPixa(paa: *mut PIXAA, pixa: *mut PIXA, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaExtendArray(paa: *mut PIXAA) -> l_int32;
}
extern "C" {
    pub fn pixaaAddPix(
        paa: *mut PIXAA,
        index: l_int32,
        pix: *mut PIX,
        box_: *mut BOX,
        copyflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaaAddBox(paa: *mut PIXAA, box_: *mut BOX, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaGetCount(paa: *mut PIXAA, pna: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixaaGetPixa(paa: *mut PIXAA, index: l_int32, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaGetBoxa(paa: *mut PIXAA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaaGetPix(
        paa: *mut PIXAA,
        index: l_int32,
        ipix: l_int32,
        accessflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaVerifyDepth(paa: *mut PIXAA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaVerifyDimensions(
        paa: *mut PIXAA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaaIsFull(paa: *mut PIXAA, pfull: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaInitFull(paa: *mut PIXAA, pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaaReplacePixa(paa: *mut PIXAA, index: l_int32, pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaaClear(paa: *mut PIXAA) -> l_int32;
}
extern "C" {
    pub fn pixaaTruncate(paa: *mut PIXAA) -> l_int32;
}
extern "C" {
    pub fn pixaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadStream(fp: *mut FILE) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadMem(data: *const l_uint8, size: usize) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWrite(filename: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaWriteStream(fp: *mut FILE, pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaReadBoth(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadStream(fp: *mut FILE) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadMem(data: *const l_uint8, size: usize) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaWrite(filename: *const ::std::os::raw::c_char, paa: *mut PIXAA) -> l_int32;
}
extern "C" {
    pub fn pixaaWriteStream(fp: *mut FILE, paa: *mut PIXAA) -> l_int32;
}
extern "C" {
    pub fn pixaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, paa: *mut PIXAA) -> l_int32;
}
extern "C" {
    pub fn pixaccCreate(w: l_int32, h: l_int32, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccCreateFromPix(pix: *mut PIX, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccDestroy(ppixacc: *mut *mut PIXACC);
}
extern "C" {
    pub fn pixaccFinal(pixacc: *mut PIXACC, outdepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetPix(pixacc: *mut PIXACC) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetOffset(pixacc: *mut PIXACC) -> l_int32;
}
extern "C" {
    pub fn pixaccAdd(pixacc: *mut PIXACC, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixaccSubtract(pixacc: *mut PIXACC, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixaccMultConst(pixacc: *mut PIXACC, factor: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixaccMultConstAccumulate(
        pixacc: *mut PIXACC,
        pix: *mut PIX,
        factor: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSelectBySize(
        pixs: *mut PIX,
        width: l_int32,
        height: l_int32,
        connectivity: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectBySize(
        pixas: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeSizeIndicator(
        pixa: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSelectByPerimToAreaRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimToAreaRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByPerimSizeRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimSizeRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByAreaFraction(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByAreaFraction(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByWidthHeightRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByWidthHeightRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectByNumConnComp(
        pixas: *mut PIXA,
        nmin: l_int32,
        nmax: l_int32,
        connectivity: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectWithIndicator(
        pixas: *mut PIXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixRemoveWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixAddWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixaSelectWithString(
        pixas: *mut PIXA,
        str: *const ::std::os::raw::c_char,
        perror: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRenderComponent(pixs: *mut PIX, pixa: *mut PIXA, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaBinSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSortByIndex(pixas: *mut PIXA, naindex: *mut NUMA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSort2dByIndex(pixas: *mut PIXA, naa: *mut NUMAA, copyflag: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaSelectRange(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSelectRange(
        paas: *mut PIXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSize(paas: *mut PIXAA, wd: l_int32, hd: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSizeVar(paas: *mut PIXAA, nawd: *mut NUMA, nahd: *mut NUMA) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaScaleToSize(pixas: *mut PIXA, wd: l_int32, hd: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleToSizeRel(pixas: *mut PIXA, delw: l_int32, delh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScale(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddBorderGeneral(
        pixad: *mut PIXA,
        pixas: *mut PIXA,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaFlattenToPixa(
        paa: *mut PIXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSizeRange(
        paa: *mut PIXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaSizeRange(
        pixa: *mut PIXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaClipToPix(pixas: *mut PIXA, pixs: *mut PIX) -> *mut PIXA;
}
extern "C" {
    pub fn pixaClipToForeground(
        pixas: *mut PIXA,
        ppixad: *mut *mut PIXA,
        pboxa: *mut *mut BOXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaGetRenderingDepth(pixa: *mut PIXA, pdepth: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaHasColor(pixa: *mut PIXA, phascolor: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAnyColormaps(pixa: *mut PIXA, phascmap: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaGetDepthInfo(
        pixa: *mut PIXA,
        pmaxdepth: *mut l_int32,
        psame: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaConvertToSameDepth(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaEqual(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaRotateOrth(pixas: *mut PIXA, rotation: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSetFullSizeBoxa(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaDisplay(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayOnColor(
        pixa: *mut PIXA,
        w: l_int32,
        h: l_int32,
        bgcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayRandomCmap(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayLinearly(
        pixas: *mut PIXA,
        direction: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayOnLattice(
        pixa: *mut PIXA,
        cellw: l_int32,
        cellh: l_int32,
        pncols: *mut l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayUnsplit(
        pixa: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiled(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        background: l_int32,
        spacing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInRows(
        pixa: *mut PIXA,
        outdepth: l_int32,
        maxwidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInColumns(
        pixas: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledAndScaled(
        pixa: *mut PIXA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledWithText(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledByIndex(
        pixa: *mut PIXA,
        na: *mut NUMA,
        width: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplay(paa: *mut PIXAA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayByPixa(
        paa: *mut PIXAA,
        xspace: l_int32,
        yspace: l_int32,
        maxw: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayTiledAndScaled(
        paa: *mut PIXAA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo1(pixas: *mut PIXA, thresh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8(pixas: *mut PIXA, cmapflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8Colormap(pixas: *mut PIXA, dither: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo32(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConstrainedSelect(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectToPdf(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        color: l_uint32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaDisplayMultiTiled(
        pixas: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        maxw: l_int32,
        maxh: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitIntoFiles(
        pixas: *mut PIXA,
        nsplit: l_int32,
        scale: l_float32,
        outwidth: l_int32,
        write_pixa: l_int32,
        write_pix: l_int32,
        write_pdf: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertToNUpFiles(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertToNUpPixa(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToNUpPixa(
        pixas: *mut PIXA,
        sa: *mut SARRAY,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCompareInPdf(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pmsCreate(
        minsize: usize,
        smallest: usize,
        numalloc: *mut NUMA,
        logfile: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pmsDestroy();
}
extern "C" {
    pub fn pmsCustomAlloc(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsCustomDealloc(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pmsGetAlloc(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsGetLevelForAlloc(nbytes: usize, plevel: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pmsGetLevelForDealloc(
        data: *mut ::std::os::raw::c_void,
        plevel: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pmsLogInfo();
}
extern "C" {
    pub fn pixAddConstantGray(pixs: *mut PIX, val: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixMultConstantGray(pixs: *mut PIX, val: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixAddGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtractGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdToValue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        threshval: l_int32,
        setval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInitAccumulate(w: l_int32, h: l_int32, offset: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulate(pixs: *mut PIX, offset: l_uint32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulateThreshold(
        pixs: *mut PIX,
        offset: l_uint32,
        threshold: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAccumulate(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixMultConstAccumulate(pixs: *mut PIX, factor: l_float32, offset: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixAbsDifference(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRGB(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMinOrMax(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRange(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRangeRGB(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn linearScaleRGBVal(sval: l_uint32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn logScaleRGBVal(sval: l_uint32, tab: *mut l_float32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn makeLogBase2Tab() -> *mut l_float32;
}
extern "C" {
    pub fn getLogBase2(val: l_int32, logtab: *mut l_float32) -> l_float32;
}
extern "C" {
    pub fn pixcompCreateFromPix(pix: *mut PIX, comptype: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromString(data: *mut l_uint8, size: usize, copyflag: l_int32)
        -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompDestroy(ppixc: *mut *mut PIXC);
}
extern "C" {
    pub fn pixcompCopy(pixcs: *mut PIXC) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompGetDimensions(
        pixc: *mut PIXC,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcompDetermineFormat(
        comptype: l_int32,
        d: l_int32,
        cmapflag: l_int32,
        pformat: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCreateFromPixcomp(pixc: *mut PIXC) -> *mut PIX;
}
extern "C" {
    pub fn pixacompCreate(n: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateWithInit(
        n: l_int32,
        offset: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromPixa(
        pixa: *mut PIXA,
        comptype: l_int32,
        accesstype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromSA(sa: *mut SARRAY, comptype: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompDestroy(ppixac: *mut *mut PIXAC);
}
extern "C" {
    pub fn pixacompAddPix(pixac: *mut PIXAC, pix: *mut PIX, comptype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixacompAddPixcomp(pixac: *mut PIXAC, pixc: *mut PIXC, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixacompReplacePix(
        pixac: *mut PIXAC,
        index: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompReplacePixcomp(pixac: *mut PIXAC, index: l_int32, pixc: *mut PIXC) -> l_int32;
}
extern "C" {
    pub fn pixacompAddBox(pixac: *mut PIXAC, box_: *mut BOX, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixacompGetCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetPixcomp(pixac: *mut PIXAC, index: l_int32, copyflag: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixacompGetPix(pixac: *mut PIXAC, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixacompGetPixDimensions(
        pixac: *mut PIXAC,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompGetBoxa(pixac: *mut PIXAC, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixacompGetBoxaCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetBox(pixac: *mut PIXAC, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixacompGetBoxGeometry(
        pixac: *mut PIXAC,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompGetOffset(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompSetOffset(pixac: *mut PIXAC, offset: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaCreateFromPixacomp(pixac: *mut PIXAC, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixacompJoin(
        pixacd: *mut PIXAC,
        pixacs: *mut PIXAC,
        istart: l_int32,
        iend: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompInterleave(pixac1: *mut PIXAC, pixac2: *mut PIXAC) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadStream(fp: *mut FILE) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadMem(data: *const l_uint8, size: usize) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompWrite(filename: *const ::std::os::raw::c_char, pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompWriteStream(fp: *mut FILE, pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pixac: *mut PIXAC,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompConvertToPdf(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompConvertToPdfData(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompWriteStreamInfo(
        fp: *mut FILE,
        pixac: *mut PIXAC,
        text: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcompWriteStreamInfo(
        fp: *mut FILE,
        pixc: *mut PIXC,
        text: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixacompDisplayTiledAndScaled(
        pixac: *mut PIXAC,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThreshold8(
        pixs: *mut PIX,
        d: l_int32,
        nlevels: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormapGeneral(pixs: *mut PIX, type_: l_int32, ifnocmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormap(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddGrayColormap8(pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixAddMinimalGrayColormap8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToLuminance(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGray(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayFast(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayMinMax(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGraySatBoost(pixs: *mut PIX, refval: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToBinaryArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_int32,
        relation: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap8(pixs: *mut PIX, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixColorizeGray(pixs: *mut PIX, color: l_uint32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToColormap(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertCmapTo1(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantizeIfFewColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        mingraycolors: l_int32,
        octlevel: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConvert16To8(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToFalseColor(pixs: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnpackBinary(pixs: *mut PIX, depth: l_int32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To16(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint16,
        val1: l_uint16,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To32(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint32,
        val1: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8(pixd: *mut PIX, pixs: *mut PIX, val0: l_uint8, val1: l_uint8)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert2To8(
        pixs: *mut PIX,
        val0: l_uint8,
        val1: l_uint8,
        val2: l_uint8,
        val3: l_uint8,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert4To8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To16(pixs: *mut PIX, leftshift: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To4(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1(pixs: *mut PIX, threshold: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1BySampling(pixs: *mut PIX, factor: l_int32, threshold: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8BySampling(pixs: *mut PIX, factor: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Colormap(pixs: *mut PIX, dither: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32BySampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Or32(pixs: *mut PIX, copyflag: l_int32, warnflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert24To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To24(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To16(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To8(pixs: *mut PIX, type16: l_int32, type8: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveAlpha(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaTo1bpp(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertLossless(pixs: *mut PIX, d: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertForPSWrap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertColorToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setNeutralBoostVal(val: l_int32);
}
extern "C" {
    pub fn pixConnCompTransform(pixs: *mut PIX, connect: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompAreaTransform(pixs: *mut PIX, connect: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompIncrInit(
        pixs: *mut PIX,
        conn: l_int32,
        ppixd: *mut *mut PIX,
        pptaa: *mut *mut PTAA,
        pncc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixConnCompIncrAdd(
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pncc: *mut l_int32,
        x: l_float32,
        y: l_float32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetSortedNeighborValues(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        conn: l_int32,
        pneigh: *mut *mut l_int32,
        pnvals: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixLocToColorTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingCreate(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        w: l_int32,
        h: l_int32,
        xoverlap: l_int32,
        yoverlap: l_int32,
    ) -> *mut PIXTILING;
}
extern "C" {
    pub fn pixTilingDestroy(ppt: *mut *mut PIXTILING);
}
extern "C" {
    pub fn pixTilingGetCount(pt: *mut PIXTILING, pnx: *mut l_int32, pny: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixTilingGetSize(pt: *mut PIXTILING, pw: *mut l_int32, ph: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixTilingGetTile(pt: *mut PIXTILING, i: l_int32, j: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingNoStripOnPaint(pt: *mut PIXTILING) -> l_int32;
}
extern "C" {
    pub fn pixTilingPaintTile(
        pixd: *mut PIX,
        i: l_int32,
        j: l_int32,
        pixs: *mut PIX,
        pt: *mut PIXTILING,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadStreamPng(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPng(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn readHeaderMemPng(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fgetPngResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn isPngInterlaced(
        filename: *const ::std::os::raw::c_char,
        pinterlaced: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fgetPngColormapInfo(
        fp: *mut FILE,
        pcmap: *mut *mut PIXCMAP,
        ptransparency: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWritePng(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamPng(fp: *mut FILE, pix: *mut PIX, gamma: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixSetZlibCompression(pix: *mut PIX, compval: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_pngSetReadStrip16To8(flag: l_int32);
}
extern "C" {
    pub fn pixReadMemPng(filedata: *const l_uint8, filesize: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemPng(
        pfiledata: *mut *mut l_uint8,
        pfilesize: *mut usize,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadStreamPnm(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPnm(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamPnm(fp: *mut FILE, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamAsciiPnm(fp: *mut FILE, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamPam(fp: *mut FILE, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixReadMemPnm(data: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemPnm(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemPnm(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemPam(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixProjectiveSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjective(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getProjectiveXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn projectiveXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn projectiveXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertFilesToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayConvertFilesToPS(
        sa: *mut SARRAY,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertFilesFittedToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayConvertFilesFittedToPS(
        sa: *mut SARRAY,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn writeImageCompressedToPSFile(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        pfirstfile: *mut l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertSegmentedPagesToPS(
        pagedir: *const ::std::os::raw::c_char,
        pagestr: *const ::std::os::raw::c_char,
        page_numpre: l_int32,
        maskdir: *const ::std::os::raw::c_char,
        maskstr: *const ::std::os::raw::c_char,
        mask_numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteSegmentedPageToPS(
        pixs: *mut PIX,
        pixm: *mut PIX,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMixedToPS(
        pixb: *mut PIX,
        pixc: *mut PIX,
        scale: l_float32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        level: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaWriteCompressedToPS(
        pixa: *mut PIXA,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWritePSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamPS(
        fp: *mut FILE,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStringPS(
        pixs: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn generateUncompressedPS(
        hexdata: *mut ::std::os::raw::c_char,
        w: l_int32,
        h: l_int32,
        d: l_int32,
        psbpl: l_int32,
        bps: l_int32,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        boxflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getScaledParametersPS(
        box_: *mut BOX,
        wpix: l_int32,
        hpix: l_int32,
        res: l_int32,
        scale: l_float32,
        pxpt: *mut l_float32,
        pypt: *mut l_float32,
        pwpt: *mut l_float32,
        phpt: *mut l_float32,
    );
}
extern "C" {
    pub fn convertByteToHexAscii(
        byteval: l_uint8,
        pnib1: *mut ::std::os::raw::c_char,
        pnib2: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn convertJpegToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertJpegToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertJpegToPSString(
        filein: *const ::std::os::raw::c_char,
        poutstr: *mut *mut ::std::os::raw::c_char,
        pnbytes: *mut l_int32,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn generateJpegPS(
        filein: *const ::std::os::raw::c_char,
        cid: *mut L_COMP_DATA,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertG4ToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertG4ToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        maskflag: l_int32,
        endpage: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertG4ToPSString(
        filein: *const ::std::os::raw::c_char,
        poutstr: *mut *mut ::std::os::raw::c_char,
        pnbytes: *mut l_int32,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        maskflag: l_int32,
        endpage: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn generateG4PS(
        filein: *const ::std::os::raw::c_char,
        cid: *mut L_COMP_DATA,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        maskflag: l_int32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertTiffMultipageToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        fillfract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertFlateToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn convertFlateToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn convertFlateToPSString(
        filein: *const ::std::os::raw::c_char,
        poutstr: *mut *mut ::std::os::raw::c_char,
        pnbytes: *mut l_int32,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn generateFlatePS(
        filein: *const ::std::os::raw::c_char,
        cid: *mut L_COMP_DATA,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixWriteMemPS(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn getResLetterPage(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn getResA4Page(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_psWriteBoundingBox(flag: l_int32);
}
extern "C" {
    pub fn ptaCreate(n: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaCreateFromNuma(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaDestroy(ppta: *mut *mut PTA);
}
extern "C" {
    pub fn ptaCopy(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCopyRange(ptas: *mut PTA, istart: l_int32, iend: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaClone(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEmpty(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaAddPt(pta: *mut PTA, x: l_float32, y: l_float32) -> l_int32;
}
extern "C" {
    pub fn ptaInsertPt(pta: *mut PTA, index: l_int32, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaRemovePt(pta: *mut PTA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetRefcount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaChangeRefcount(pta: *mut PTA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetCount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaGetPt(
        pta: *mut PTA,
        index: l_int32,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaGetIPt(pta: *mut PTA, index: l_int32, px: *mut l_int32, py: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaSetPt(pta: *mut PTA, index: l_int32, x: l_float32, y: l_float32) -> l_int32;
}
extern "C" {
    pub fn ptaGetArrays(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn ptaRead(filename: *const ::std::os::raw::c_char) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadStream(fp: *mut FILE) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadMem(data: *const l_uint8, size: usize) -> *mut PTA;
}
extern "C" {
    pub fn ptaWrite(
        filename: *const ::std::os::raw::c_char,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaWriteStream(fp: *mut FILE, pta: *mut PTA, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaaCreate(n: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaDestroy(pptaa: *mut *mut PTAA);
}
extern "C" {
    pub fn ptaaAddPta(ptaa: *mut PTAA, pta: *mut PTA, copyflag: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaaGetCount(ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn ptaaGetPta(ptaa: *mut PTAA, index: l_int32, accessflag: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetPt(
        ptaa: *mut PTAA,
        ipta: l_int32,
        jpt: l_int32,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaaInitFull(ptaa: *mut PTAA, pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaaReplacePta(ptaa: *mut PTAA, index: l_int32, pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaaAddPt(ptaa: *mut PTAA, ipta: l_int32, x: l_float32, y: l_float32) -> l_int32;
}
extern "C" {
    pub fn ptaaTruncate(ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn ptaaRead(filename: *const ::std::os::raw::c_char) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadStream(fp: *mut FILE) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadMem(data: *const l_uint8, size: usize) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaWrite(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaaWriteStream(fp: *mut FILE, ptaa: *mut PTAA, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaSubsample(ptas: *mut PTA, subfactor: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaJoin(ptad: *mut PTA, ptas: *mut PTA, istart: l_int32, iend: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaaJoin(ptaad: *mut PTAA, ptaas: *mut PTAA, istart: l_int32, iend: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaReverse(ptas: *mut PTA, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaTranspose(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCyclicPerm(ptas: *mut PTA, xs: l_int32, ys: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaSelectRange(ptas: *mut PTA, first: l_int32, last: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetBoundingRegion(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn ptaGetRange(
        pta: *mut PTA,
        pminx: *mut l_float32,
        pmaxx: *mut l_float32,
        pminy: *mut l_float32,
        pmaxy: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaGetInsideBox(ptas: *mut PTA, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixFindCornerPixels(pixs: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaContainsPt(pta: *mut PTA, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaTestIntersection(pta1: *mut PTA, pta2: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaTransform(
        ptas: *mut PTA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaPtInsidePolygon(
        pta: *mut PTA,
        x: l_float32,
        y: l_float32,
        pinside: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_angleBetweenVectors(
        x1: l_float32,
        y1: l_float32,
        x2: l_float32,
        y2: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn ptaGetMinMax(
        pta: *mut PTA,
        pxmin: *mut l_float32,
        pymin: *mut l_float32,
        pxmax: *mut l_float32,
        pymax: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaSelectByValue(
        ptas: *mut PTA,
        xth: l_float32,
        yth: l_float32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaCropToMask(ptas: *mut PTA, pixm: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetLinearLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaGetQuadraticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaGetCubicLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaGetQuarticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pe: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaNoisyLinearLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaNoisyQuadraticLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn applyLinearFit(a: l_float32, b: l_float32, x: l_float32, py: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn applyQuadraticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn applyCubicFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn applyQuarticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        e: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixPlotAlongPta(
        pixs: *mut PIX,
        pta: *mut PTA,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaGetPixelsFromPix(pixs: *mut PIX, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixGenerateFromPta(pta: *mut PTA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn ptaGetBoundaryPixels(pixs: *mut PIX, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetBoundaryPixels(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaIndexLabeledPixels(pixs: *mut PIX, pncc: *mut l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetNeighborPixLocs(pixs: *mut PIX, x: l_int32, y: l_int32, conn: l_int32)
        -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta1(na: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta2(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToNuma(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixDisplayPta(pixd: *mut PIX, pixs: *mut PIX, pta: *mut PTA) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pta: *mut PTA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ptaReplicatePattern(
        ptas: *mut PTA,
        pixp: *mut PIX,
        ptap: *mut PTA,
        cx: l_int32,
        cy: l_int32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDisplayPtaa(pixs: *mut PIX, ptaa: *mut PTAA) -> *mut PIX;
}
extern "C" {
    pub fn ptaSort(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetSortIndex(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaSortByIndex(ptas: *mut PTA, naindex: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaaSortByIndex(ptaas: *mut PTAA, naindex: *mut NUMA) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetRankValue(
        pta: *mut PTA,
        fract: l_float32,
        ptasort: *mut PTA,
        sorttype: l_int32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaUnionByAset(pta1: *mut PTA, pta2: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaRemoveDupsByAset(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaIntersectionByAset(pta1: *mut PTA, pta2: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn l_asetCreateFromPta(pta: *mut PTA) -> *mut L_ASET;
}
extern "C" {
    pub fn ptaUnionByHash(pta1: *mut PTA, pta2: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaRemoveDupsByHash(
        ptas: *mut PTA,
        pptad: *mut *mut PTA,
        pdahash: *mut *mut L_DNAHASH,
    ) -> l_int32;
}
extern "C" {
    pub fn ptaIntersectionByHash(pta1: *mut PTA, pta2: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaFindPtByHash(
        pta: *mut PTA,
        dahash: *mut L_DNAHASH,
        x: l_int32,
        y: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaHashCreateFromPta(pta: *mut PTA) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn ptraCreate(n: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraDestroy(ppa: *mut *mut L_PTRA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraAdd(pa: *mut L_PTRA, item: *mut ::std::os::raw::c_void) -> l_int32;
}
extern "C" {
    pub fn ptraInsert(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        shiftflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn ptraRemove(
        pa: *mut L_PTRA,
        index: l_int32,
        flag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraRemoveLast(pa: *mut L_PTRA) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraReplace(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        freeflag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraSwap(pa: *mut L_PTRA, index1: l_int32, index2: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptraCompactArray(pa: *mut L_PTRA) -> l_int32;
}
extern "C" {
    pub fn ptraReverse(pa: *mut L_PTRA) -> l_int32;
}
extern "C" {
    pub fn ptraJoin(pa1: *mut L_PTRA, pa2: *mut L_PTRA) -> l_int32;
}
extern "C" {
    pub fn ptraGetMaxIndex(pa: *mut L_PTRA, pmaxindex: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptraGetActualCount(pa: *mut L_PTRA, pcount: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptraGetPtrToItem(pa: *mut L_PTRA, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraaCreate(n: l_int32) -> *mut L_PTRAA;
}
extern "C" {
    pub fn ptraaDestroy(ppaa: *mut *mut L_PTRAA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraaGetSize(paa: *mut L_PTRAA, psize: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptraaInsertPtra(paa: *mut L_PTRAA, index: l_int32, pa: *mut L_PTRA) -> l_int32;
}
extern "C" {
    pub fn ptraaGetPtra(paa: *mut L_PTRAA, index: l_int32, accessflag: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraaFlattenToPtra(paa: *mut L_PTRAA) -> *mut L_PTRA;
}
extern "C" {
    pub fn pixQuadtreeMean(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        pfpixa: *mut *mut FPIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixQuadtreeVariance(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pfpixa_v: *mut *mut FPIXA,
        pfpixa_rv: *mut *mut FPIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMeanInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixma: *mut PIX,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixVarianceInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn boxaaQuadtreeRegions(w: l_int32, h: l_int32, nlevels: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn quadtreeGetParent(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn quadtreeGetChildren(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval00: *mut l_float32,
        pval10: *mut l_float32,
        pval01: *mut l_float32,
        pval11: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn quadtreeMaxLevels(w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaDisplayQuadtree(fpixa: *mut FPIXA, factor: l_int32, fontsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn lqueueCreate(nalloc: l_int32) -> *mut L_QUEUE;
}
extern "C" {
    pub fn lqueueDestroy(plq: *mut *mut L_QUEUE, freeflag: l_int32);
}
extern "C" {
    pub fn lqueueAdd(lq: *mut L_QUEUE, item: *mut ::std::os::raw::c_void) -> l_int32;
}
extern "C" {
    pub fn lqueueRemove(lq: *mut L_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lqueueGetCount(lq: *mut L_QUEUE) -> l_int32;
}
extern "C" {
    pub fn lqueuePrint(fp: *mut FILE, lq: *mut L_QUEUE) -> l_int32;
}
extern "C" {
    pub fn pixRankFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterRGB(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterGray(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixMedianFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterWithScaling(
        pixs: *mut PIX,
        wf: l_int32,
        hf: l_int32,
        rank: l_float32,
        scalefactor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_rbtreeCreate(keytype: l_int32) -> *mut L_RBTREE;
}
extern "C" {
    pub fn l_rbtreeLookup(t: *mut L_RBTREE, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_rbtreeInsert(t: *mut L_RBTREE, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDelete(t: *mut L_RBTREE, key: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDestroy(pt: *mut *mut L_RBTREE);
}
extern "C" {
    pub fn l_rbtreeGetFirst(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetNext(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetLast(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetPrev(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetCount(t: *mut L_RBTREE) -> l_int32;
}
extern "C" {
    pub fn l_rbtreePrint(fp: *mut FILE, t: *mut L_RBTREE);
}
extern "C" {
    pub fn pixProcessBarcodes(
        pixs: *mut PIX,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixExtractBarcodes(pixs: *mut PIX, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixReadBarcodes(
        pixa: *mut PIXA,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadBarcodeWidths(pixs: *mut PIX, method: l_int32, debugflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixLocateBarcodes(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixb: *mut *mut PIX,
        ppixm: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixDeskewBarcode(
        pixs: *mut PIX,
        pixb: *mut PIX,
        box_: *mut BOX,
        margin: l_int32,
        threshold: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBarcodeWidths1(
        pixs: *mut PIX,
        thresh: l_float32,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeWidths2(
        pixs: *mut PIX,
        thresh: l_float32,
        pwidth: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeCrossings(
        pixs: *mut PIX,
        thresh: l_float32,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWidth(
        nas: *mut NUMA,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWindow(
        nas: *mut NUMA,
        ratio: l_float32,
        pwidth: *mut l_float32,
        pfirstloc: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaReadFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadFilesSA(sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn pixRead(filename: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn pixReadWithHint(filename: *const ::std::os::raw::c_char, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadIndexed(sa: *mut SARRAY, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStream(fp: *mut FILE, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeader(
        filename: *const ::std::os::raw::c_char,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn findFileFormat(
        filename: *const ::std::os::raw::c_char,
        pformat: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn findFileFormatStream(fp: *mut FILE, pformat: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn findFileFormatBuffer(buf: *const l_uint8, pformat: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixReadMem(data: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeaderMem(
        data: *const l_uint8,
        size: usize,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn writeImageFileInfo(
        filename: *const ::std::os::raw::c_char,
        fpout: *mut FILE,
        headeronly: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogCreateFromRecog(
        recs: *mut L_RECOG,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixa(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixaNoFinish(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreate(
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogDestroy(precog: *mut *mut L_RECOG);
}
extern "C" {
    pub fn recogGetCount(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogSetParams(
        recog: *mut L_RECOG,
        type_: l_int32,
        min_nopad: l_int32,
        max_wh_ratio: l_float32,
        max_ht_ratio: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogGetClassIndex(
        recog: *mut L_RECOG,
        val: l_int32,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogStringToIndex(
        recog: *mut L_RECOG,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogGetClassString(
        recog: *mut L_RECOG,
        index: l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_convertCharstrToInt(str: *const ::std::os::raw::c_char, pval: *mut l_int32)
        -> l_int32;
}
extern "C" {
    pub fn recogRead(filename: *const ::std::os::raw::c_char) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadStream(fp: *mut FILE) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadMem(data: *const l_uint8, size: usize) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogWrite(filename: *const ::std::os::raw::c_char, recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogWriteStream(fp: *mut FILE, recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        recog: *mut L_RECOG,
    ) -> l_int32;
}
extern "C" {
    pub fn recogExtractPixa(recog: *mut L_RECOG) -> *mut PIXA;
}
extern "C" {
    pub fn recogDecode(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        nlevels: l_int32,
        ppixdb: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn recogCreateDid(recog: *mut L_RECOG, pixs: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn recogDestroyDid(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogDidExists(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogGetDid(recog: *mut L_RECOG) -> *mut L_RDID;
}
extern "C" {
    pub fn recogSetChannelParams(recog: *mut L_RECOG, nlevels: l_int32) -> l_int32;
}
extern "C" {
    pub fn recogIdentifyMultiple(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdb: *mut *mut PIX,
        debugsplit: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogSplitIntoCharacters(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogCorrelationBestRow(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pboxa: *mut *mut BOXA,
        pnascore: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        psachar: *mut *mut SARRAY,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogCorrelationBestChar(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pbox: *mut *mut BOX,
        pscore: *mut l_float32,
        pindex: *mut l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn recogIdentifyPixa(
        recog: *mut L_RECOG,
        pixa: *mut PIXA,
        ppixdb: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn recogIdentifyPix(recog: *mut L_RECOG, pixs: *mut PIX, ppixdb: *mut *mut PIX) -> l_int32;
}
extern "C" {
    pub fn recogSkipIdentify(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn rchaDestroy(prcha: *mut *mut L_RCHA);
}
extern "C" {
    pub fn rchDestroy(prch: *mut *mut L_RCH);
}
extern "C" {
    pub fn rchaExtract(
        rcha: *mut L_RCHA,
        pnaindex: *mut *mut NUMA,
        pnascore: *mut *mut NUMA,
        psatext: *mut *mut SARRAY,
        pnasample: *mut *mut NUMA,
        pnaxloc: *mut *mut NUMA,
        pnayloc: *mut *mut NUMA,
        pnawidth: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn rchExtract(
        rch: *mut L_RCH,
        pindex: *mut l_int32,
        pscore: *mut l_float32,
        ptext: *mut *mut ::std::os::raw::c_char,
        psample: *mut l_int32,
        pxloc: *mut l_int32,
        pyloc: *mut l_int32,
        pwidth: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogProcessToIdentify(recog: *mut L_RECOG, pixs: *mut PIX, pad: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn recogExtractNumbers(
        recog: *mut L_RECOG,
        boxas: *mut BOXA,
        scorethresh: l_float32,
        spacethresh: l_int32,
        pbaa: *mut *mut BOXAA,
        pnaa: *mut *mut NUMAA,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn showExtractNumbers(
        pixs: *mut PIX,
        sa: *mut SARRAY,
        baa: *mut BOXAA,
        naa: *mut NUMAA,
        ppixdb: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogProcessLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        ppix: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn recogAddSample(recog: *mut L_RECOG, pix: *mut PIX, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn recogModifyTemplate(recog: *mut L_RECOG, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn recogAverageSamples(precog: *mut *mut L_RECOG, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAccumulateSamples(
        pixa: *mut PIXA,
        pta: *mut PTA,
        ppixd: *mut *mut PIX,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogTrainingFinished(
        precog: *mut *mut L_RECOG,
        modifyflag: l_int32,
        minsize: l_int32,
        minfract: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogFilterPixaBySize(
        pixas: *mut PIXA,
        setsize: l_int32,
        maxkeep: l_int32,
        max_ht_ratio: l_float32,
        pna: *mut *mut NUMA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogSortPixaByClass(pixa: *mut PIXA, setsize: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn recogRemoveOutliers1(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaRemoveOutliers1(
        pixas: *mut PIXA,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogRemoveOutliers2(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaRemoveOutliers2(
        pixas: *mut PIXA,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainFromBoot(
        recogboot: *mut L_RECOG,
        pixas: *mut PIXA,
        minscore: l_float32,
        threshold: l_int32,
        debug: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogPadDigitTrainingSet(
        precog: *mut *mut L_RECOG,
        scaleh: l_int32,
        linew: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogIsPaddingNeeded(recog: *mut L_RECOG, psa: *mut *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn recogAddDigitPadTemplates(recog: *mut L_RECOG, sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn recogMakeBootDigitRecog(
        scaleh: l_int32,
        linew: l_int32,
        maxyshift: l_int32,
        debug: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogMakeBootDigitTemplates(debug: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn recogShowContent(
        fp: *mut FILE,
        recog: *mut L_RECOG,
        index: l_int32,
        display: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogDebugAverages(precog: *mut *mut L_RECOG, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn recogShowAverageTemplates(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogShowMatchesInRange(
        recog: *mut L_RECOG,
        pixa: *mut PIXA,
        minscore: l_float32,
        maxscore: l_float32,
        display: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogShowMatch(
        recog: *mut L_RECOG,
        pix1: *mut PIX,
        pix2: *mut PIX,
        box_: *mut BOX,
        index: l_int32,
        score: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn regTestSetup(
        argc: l_int32,
        argv: *mut *mut ::std::os::raw::c_char,
        prp: *mut *mut L_REGPARAMS,
    ) -> l_int32;
}
extern "C" {
    pub fn regTestCleanup(rp: *mut L_REGPARAMS) -> l_int32;
}
extern "C" {
    pub fn regTestCompareValues(
        rp: *mut L_REGPARAMS,
        val1: l_float32,
        val2: l_float32,
        delta: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn regTestCompareStrings(
        rp: *mut L_REGPARAMS,
        string1: *mut l_uint8,
        bytes1: usize,
        string2: *mut l_uint8,
        bytes2: usize,
    ) -> l_int32;
}
extern "C" {
    pub fn regTestComparePix(rp: *mut L_REGPARAMS, pix1: *mut PIX, pix2: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn regTestCompareSimilarPix(
        rp: *mut L_REGPARAMS,
        pix1: *mut PIX,
        pix2: *mut PIX,
        mindiff: l_int32,
        maxfract: l_float32,
        printstats: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn regTestCheckFile(
        rp: *mut L_REGPARAMS,
        localname: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn regTestCompareFiles(rp: *mut L_REGPARAMS, index1: l_int32, index2: l_int32) -> l_int32;
}
extern "C" {
    pub fn regTestWritePixAndCheck(rp: *mut L_REGPARAMS, pix: *mut PIX, format: l_int32)
        -> l_int32;
}
extern "C" {
    pub fn regTestWriteDataAndCheck(
        rp: *mut L_REGPARAMS,
        data: *mut ::std::os::raw::c_void,
        nbytes: usize,
        ext: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn regTestGenLocalFilename(
        rp: *mut L_REGPARAMS,
        index: l_int32,
        format: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixRasterop(
        pixd: *mut PIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRasteropVip(
        pixd: *mut PIX,
        bx: l_int32,
        bw: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRasteropHip(
        pixd: *mut PIX,
        by: l_int32,
        bh: l_int32,
        hshift: l_int32,
        incolor: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixTranslate(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRasteropIP(
        pixd: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRasteropFullImage(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_int32;
}
extern "C" {
    pub fn rasteropUniLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
    );
}
extern "C" {
    pub fn rasteropLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        datas: *mut l_uint32,
        spixw: l_int32,
        spixh: l_int32,
        swpl: l_int32,
        sx: l_int32,
        sy: l_int32,
    );
}
extern "C" {
    pub fn rasteropVipLow(
        data: *mut l_uint32,
        pixw: l_int32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        x: l_int32,
        w: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn rasteropHipLow(
        data: *mut l_uint32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        y: l_int32,
        h: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn pixRotate(
        pixs: *mut PIX,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEmbedForRotation(
        pixs: *mut PIX,
        angle: l_float32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBySampling(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBinaryNice(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateWithAlpha(
        pixs: *mut PIX,
        angle: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAM(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColor(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGray(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMCorner(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorCorner(pixs: *mut PIX, angle: l_float32, fillval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGrayCorner(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorFast(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateOrth(pixs: *mut PIX, quads: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate180(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate90(pixs: *mut PIX, direction: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipLR(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipTB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate2Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate3Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearIP(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRotateShearCenter(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearCenterIP(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixStrokeWidthTransform(
        pixs: *mut PIX,
        color: l_int32,
        depth: l_int32,
        nangles: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunlengthTransform(
        pixs: *mut PIX,
        color: l_int32,
        direction: l_int32,
        depth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHorizontalRuns(
        pix: *mut PIX,
        y: l_int32,
        xstart: *mut l_int32,
        xend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindVerticalRuns(
        pix: *mut PIX,
        x: l_int32,
        ystart: *mut l_int32,
        yend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindMaxRuns(pix: *mut PIX, direction: l_int32, pnastart: *mut *mut NUMA)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindMaxHorizontalRunOnLine(
        pix: *mut PIX,
        y: l_int32,
        pxstart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindMaxVerticalRunOnLine(
        pix: *mut PIX,
        x: l_int32,
        pystart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn runlengthMembershipOnLine(
        buffer: *mut l_int32,
        size: l_int32,
        depth: l_int32,
        start: *mut l_int32,
        end: *mut l_int32,
        n: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn makeMSBitLocTab(bitval: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn sarrayCreate(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateInitialized(n: l_int32, initstr: *mut ::std::os::raw::c_char)
        -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateWordsFromString(string: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateLinesFromString(
        string: *const ::std::os::raw::c_char,
        blankflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayDestroy(psa: *mut *mut SARRAY);
}
extern "C" {
    pub fn sarrayCopy(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayClone(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayAddString(
        sa: *mut SARRAY,
        string: *mut ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayRemoveString(sa: *mut SARRAY, index: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayReplaceString(
        sa: *mut SARRAY,
        index: l_int32,
        newstr: *mut ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayClear(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayGetCount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayGetArray(
        sa: *mut SARRAY,
        pnalloc: *mut l_int32,
        pn: *mut l_int32,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetString(
        sa: *mut SARRAY,
        index: l_int32,
        copyflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetRefcount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayChangeRefcount(sa: *mut SARRAY, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn sarrayToString(sa: *mut SARRAY, addnlflag: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToStringRange(
        sa: *mut SARRAY,
        first: l_int32,
        nstrings: l_int32,
        addnlflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayJoin(sa1: *mut SARRAY, sa2: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayAppendRange(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        start: l_int32,
        end: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayPadToSameSize(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        padstring: *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayConvertWordsToLines(sa: *mut SARRAY, linesize: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySplitString(
        sa: *mut SARRAY,
        str: *const ::std::os::raw::c_char,
        separators: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarraySelectBySubstring(
        sain: *mut SARRAY,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySelectByRange(sain: *mut SARRAY, first: l_int32, last: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayParseRange(
        sa: *mut SARRAY,
        start: l_int32,
        pactualstart: *mut l_int32,
        pend: *mut l_int32,
        pnewstart: *mut l_int32,
        substr: *const ::std::os::raw::c_char,
        loc: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayRead(filename: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadStream(fp: *mut FILE) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadMem(data: *const l_uint8, size: usize) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayWrite(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayWriteStream(fp: *mut FILE, sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayAppend(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn getNumberedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getSortedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn convertSortedToNumberedPathnames(
        sa: *mut SARRAY,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getFilenamesInDirectory(dirname: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySort(saout: *mut SARRAY, sain: *mut SARRAY, sortorder: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySortByIndex(sain: *mut SARRAY, naindex: *mut NUMA) -> *mut SARRAY;
}
extern "C" {
    pub fn stringCompareLexical(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayUnionByAset(sa1: *mut SARRAY, sa2: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayRemoveDupsByAset(sas: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayIntersectionByAset(sa1: *mut SARRAY, sa2: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn l_asetCreateFromSarray(sa: *mut SARRAY) -> *mut L_ASET;
}
extern "C" {
    pub fn sarrayRemoveDupsByHash(
        sas: *mut SARRAY,
        psad: *mut *mut SARRAY,
        pdahash: *mut *mut L_DNAHASH,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayIntersectionByHash(sa1: *mut SARRAY, sa2: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayFindStringByHash(
        sa: *mut SARRAY,
        dahash: *mut L_DNAHASH,
        str: *const ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_dnaHashCreateFromSarray(sa: *mut SARRAY) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn sarrayGenerateIntegers(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayLookupCSKV(
        sa: *mut SARRAY,
        keystring: *const ::std::os::raw::c_char,
        pvalstring: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixScale(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSizeRel(pixs: *mut PIX, delw: l_int32, delh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGeneral(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        sharpfract: l_float32,
        sharpwidth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColorLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySampling(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySamplingToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleByIntSampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGrayFast(pixs: *mut PIX, factor: l_int32, color: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmooth(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmoothToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGray2(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMapToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBinary(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayFast(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray3(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray6(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayMipmap(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleMipmap(pixs1: *mut PIX, pixs2: *mut PIX, scale: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandReplicate(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax(
        pixs: *mut PIX,
        xfact: l_int32,
        yfact: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax2(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRankCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRank2(pixs: *mut PIX, rank: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixScaleWithAlpha(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinary(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinaryRestricted(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        xmax: l_int32,
        ymax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHolesByFilling(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillClosedBorders(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillBgFromBorder(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillHolesToBoundingRect(
        pixs: *mut PIX,
        minsize: l_int32,
        maxhfract: l_float32,
        minfgfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillGray(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillGrayInv(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillGraySimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillGrayInvSimple(
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillGrayBasin(
        pixb: *mut PIX,
        pixm: *mut PIX,
        delta: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDistanceFunction(
        pixs: *mut PIX,
        connectivity: l_int32,
        outdepth: l_int32,
        boundcond: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedspread(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixLocalExtrema(
        pixs: *mut PIX,
        maxmin: l_int32,
        minmax: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSelectedLocalExtrema(
        pixs: *mut PIX,
        mindist: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindEqualValues(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectMinInConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        ppta: *mut *mut PTA,
        pnav: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRemoveSeededComponents(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        bordersize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaCreate(n: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn selaDestroy(psela: *mut *mut SELA);
}
extern "C" {
    pub fn selCreate(
        height: l_int32,
        width: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selDestroy(psel: *mut *mut SEL);
}
extern "C" {
    pub fn selCopy(sel: *mut SEL) -> *mut SEL;
}
extern "C" {
    pub fn selCreateBrick(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        type_: l_int32,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateComb(factor1: l_int32, factor2: l_int32, direction: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn create2dIntArray(sy: l_int32, sx: l_int32) -> *mut *mut l_int32;
}
extern "C" {
    pub fn selaAddSel(
        sela: *mut SELA,
        sel: *mut SEL,
        selname: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn selaGetCount(sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selaGetSel(sela: *mut SELA, i: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selGetName(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selSetName(sel: *mut SEL, name: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn selaFindSelByName(
        sela: *mut SELA,
        name: *const ::std::os::raw::c_char,
        pindex: *mut l_int32,
        psel: *mut *mut SEL,
    ) -> l_int32;
}
extern "C" {
    pub fn selGetElement(sel: *mut SEL, row: l_int32, col: l_int32, ptype: *mut l_int32)
        -> l_int32;
}
extern "C" {
    pub fn selSetElement(sel: *mut SEL, row: l_int32, col: l_int32, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn selGetParameters(
        sel: *mut SEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn selSetOrigin(sel: *mut SEL, cy: l_int32, cx: l_int32) -> l_int32;
}
extern "C" {
    pub fn selGetTypeAtOrigin(sel: *mut SEL, ptype: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn selaGetBrickName(
        sela: *mut SELA,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaGetCombName(
        sela: *mut SELA,
        size: l_int32,
        direction: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getCompositeParameters(
        size: l_int32,
        psize1: *mut l_int32,
        psize2: *mut l_int32,
        pnameh1: *mut *mut ::std::os::raw::c_char,
        pnameh2: *mut *mut ::std::os::raw::c_char,
        pnamev1: *mut *mut ::std::os::raw::c_char,
        pnamev2: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn selaGetSelnames(sela: *mut SELA) -> *mut SARRAY;
}
extern "C" {
    pub fn selFindMaxTranslations(
        sel: *mut SEL,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
        pxn: *mut l_int32,
        pyn: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn selRotateOrth(sel: *mut SEL, quads: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selaRead(fname: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selaReadStream(fp: *mut FILE) -> *mut SELA;
}
extern "C" {
    pub fn selRead(fname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selReadStream(fp: *mut FILE) -> *mut SEL;
}
extern "C" {
    pub fn selaWrite(fname: *const ::std::os::raw::c_char, sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selaWriteStream(fp: *mut FILE, sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selWrite(fname: *const ::std::os::raw::c_char, sel: *mut SEL) -> l_int32;
}
extern "C" {
    pub fn selWriteStream(fp: *mut FILE, sel: *mut SEL) -> l_int32;
}
extern "C" {
    pub fn selCreateFromString(
        text: *const ::std::os::raw::c_char,
        h: l_int32,
        w: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selPrintToString(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selCreateFromPta(
        pta: *mut PTA,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromPix(
        pix: *mut PIX,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selReadFromColorImage(pathname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromColorPix(pixs: *mut PIX, selname: *mut ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selDisplayInPix(sel: *mut SEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn selaDisplayInPix(
        sela: *mut SELA,
        size: l_int32,
        gthick: l_int32,
        spacing: l_int32,
        ncols: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaAddBasic(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddHitMiss(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaLinear(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaCombs(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddCrossJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn selaAddTJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn sela4ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela4and8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn pixGenerateSelWithRuns(
        pixs: *mut PIX,
        nhlines: l_int32,
        nvlines: l_int32,
        distance: l_int32,
        minlength: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelRandom(
        pixs: *mut PIX,
        hitfract: l_float32,
        missfract: l_float32,
        distance: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelBoundary(
        pixs: *mut PIX,
        hitdist: l_int32,
        missdist: l_int32,
        hitskip: l_int32,
        missskip: l_int32,
        topflag: l_int32,
        botflag: l_int32,
        leftflag: l_int32,
        rightflag: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGetRunCentersOnLine(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        minlength: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRunsOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSubsampleBoundaryPixels(pixs: *mut PIX, skip: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn adjacentOnPixelInRaster(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        pxa: *mut l_int32,
        pya: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayHitMissSel(
        pixs: *mut PIX,
        sel: *mut SEL,
        scalefactor: l_int32,
        hitcolor: l_uint32,
        misscolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearIP(
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixVShearIP(
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixHShearLI(
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearLI(
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewBoth(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskew(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkewAndDeskew(
        pixs: *mut PIX,
        redsearch: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewGeneral(
        pixs: *mut PIX,
        redsweep: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        redsearch: l_int32,
        thresh: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkew(pixs: *mut PIX, pangle: *mut l_float32, pconf: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixFindSkewSweep(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        reduction: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearch(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScore(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScorePivot(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pivot: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindSkewOrthogonalRange(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        confprior: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindDifferentialSquareSum(pixs: *mut PIX, psum: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixFindNormalizedSquareSum(
        pixs: *mut PIX,
        phratio: *mut l_float32,
        pvratio: *mut l_float32,
        pfract: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadStreamSpix(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderSpix(
        filename: *const ::std::os::raw::c_char,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamSpix(fp: *mut FILE, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixReadMemSpix(data: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemSpix(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixSerializeToMemory(
        pixs: *mut PIX,
        pdata: *mut *mut l_uint32,
        pnbytes: *mut usize,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDeserializeFromMemory(data: *const l_uint32, nbytes: usize) -> *mut PIX;
}
extern "C" {
    pub fn lstackCreate(nalloc: l_int32) -> *mut L_STACK;
}
extern "C" {
    pub fn lstackDestroy(plstack: *mut *mut L_STACK, freeflag: l_int32);
}
extern "C" {
    pub fn lstackAdd(lstack: *mut L_STACK, item: *mut ::std::os::raw::c_void) -> l_int32;
}
extern "C" {
    pub fn lstackRemove(lstack: *mut L_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lstackGetCount(lstack: *mut L_STACK) -> l_int32;
}
extern "C" {
    pub fn lstackPrint(fp: *mut FILE, lstack: *mut L_STACK) -> l_int32;
}
extern "C" {
    pub fn strcodeCreate(fileno: l_int32) -> *mut L_STRCODE;
}
extern "C" {
    pub fn strcodeCreateFromFile(
        filein: *const ::std::os::raw::c_char,
        fileno: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn strcodeGenerate(
        strcode: *mut L_STRCODE,
        filein: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn strcodeFinalize(
        pstrcode: *mut *mut L_STRCODE,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_getStructStrFromFile(
        filename: *const ::std::os::raw::c_char,
        field: l_int32,
        pstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindStrokeLength(
        pixs: *mut PIX,
        tab8: *mut l_int32,
        plength: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindStrokeWidth(
        pixs: *mut PIX,
        thresh: l_float32,
        tab8: *mut l_int32,
        pwidth: *mut l_float32,
        pnahisto: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaFindStrokeWidth(
        pixa: *mut PIXA,
        thresh: l_float32,
        tab8: *mut l_int32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaModifyStrokeWidth(pixas: *mut PIXA, targetw: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixModifyStrokeWidth(pixs: *mut PIX, width: l_float32, targetw: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSetStrokeWidth(
        pixas: *mut PIXA,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSetStrokeWidth(
        pixs: *mut PIX,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddSingleTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
        poverflow: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddTextlines(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        wtext: l_int32,
        firstindent: l_int32,
        poverflow: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSetTextline(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        pwidth: *mut l_int32,
        poverflow: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaAddTextNumber(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        na: *mut NUMA,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddTextlines(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        sa: *mut SARRAY,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPixWithText(
        pixa: *mut PIXA,
        pixs: *mut PIX,
        reduction: l_int32,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn bmfGetLineStrings(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        maxw: l_int32,
        firstindent: l_int32,
        ph: *mut l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn bmfGetWordWidths(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bmfGetStringWidth(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn splitStringToParagraphs(
        textstr: *mut ::std::os::raw::c_char,
        splitflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadTiff(filename: *const ::std::os::raw::c_char, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamTiff(fp: *mut FILE, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteTiff(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteTiffCustom(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamTiff(fp: *mut FILE, pix: *mut PIX, comptype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamTiffWA(
        fp: *mut FILE,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadFromMultipageTiff(
        fname: *const ::std::os::raw::c_char,
        poffset: *mut usize,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMultipageTiff(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMultipageTiff(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA)
        -> l_int32;
}
extern "C" {
    pub fn writeMultipageTiff(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn writeMultipageTiffSA(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char)
        -> l_int32;
}
extern "C" {
    pub fn tiffGetCount(fp: *mut FILE, pn: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn getTiffResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn readHeaderTiff(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn readHeaderMemTiff(
        cdata: *const l_uint8,
        size: usize,
        n: l_int32,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn findTiffCompression(fp: *mut FILE, pcomptype: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn extractG4DataFromFile(
        filein: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pminisblack: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixReadMemTiff(cdata: *const l_uint8, size: usize, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemFromMultipageTiff(
        cdata: *const l_uint8,
        size: usize,
        poffset: *mut usize,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMemMultipageTiff(data: *const l_uint8, size: usize) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMemMultipageTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pixa: *mut PIXA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemTiffCustom(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        comptype: l_int32,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn setMsgSeverity(newsev: l_int32) -> l_int32;
}
extern "C" {
    pub fn convertOnLittleEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnBigEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnLittleEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertOnBigEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn genRandomIntegerInRange(range: l_int32, seed: l_int32, pval: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn lept_roundftoi(fval: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_hashStringToUint64(
        str: *const ::std::os::raw::c_char,
        phash: *mut l_uint64,
    ) -> l_int32;
}
extern "C" {
    pub fn l_hashPtToUint64(x: l_int32, y: l_int32, phash: *mut l_uint64) -> l_int32;
}
extern "C" {
    pub fn l_hashFloat64ToUint64(
        nbuckets: l_int32,
        val: l_float64,
        phash: *mut l_uint64,
    ) -> l_int32;
}
extern "C" {
    pub fn findNextLargerPrime(start: l_int32, pprime: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn lept_isPrime(n: l_uint64, pis_prime: *mut l_int32, pfactor: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn convertBinaryToGrayCode(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertGrayCodeToBinary(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn getLeptonicaVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn l_getCurrentTime(sec: *mut l_int32, usec: *mut l_int32);
}
extern "C" {
    pub fn l_getFormattedDate() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringNew(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringCopy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn stringReplace(
        pdest: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringLength(src: *const ::std::os::raw::c_char, size: usize) -> l_int32;
}
extern "C" {
    pub fn stringCat(
        dest: *mut ::std::os::raw::c_char,
        size: usize,
        src: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringConcatNew(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoin(
        src1: *const ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoinIP(
        psrc1: *mut *mut ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringReverse(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtokSafe(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        psaveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringSplitOnToken(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        phead: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringCheckForChars(
        src: *const ::std::os::raw::c_char,
        chars: *const ::std::os::raw::c_char,
        pfound: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn stringRemoveChars(
        src: *const ::std::os::raw::c_char,
        remchars: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringFindSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn stringReplaceSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        pfound: *mut l_int32,
        ploc: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        pcount: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn arrayFindEachSequence(
        data: *const l_uint8,
        datalen: usize,
        sequence: *const l_uint8,
        seqlen: usize,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn arrayFindSequence(
        data: *const l_uint8,
        datalen: usize,
        sequence: *const l_uint8,
        seqlen: usize,
        poffset: *mut l_int32,
        pfound: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_binaryRead(
        filename: *const ::std::os::raw::c_char,
        pnbytes: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadStream(fp: *mut FILE, pnbytes: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelect(
        filename: *const ::std::os::raw::c_char,
        start: usize,
        nbytes: usize,
        pnread: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelectStream(
        fp: *mut FILE,
        start: usize,
        nbytes: usize,
        pnread: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryWrite(
        filename: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        nbytes: usize,
    ) -> l_int32;
}
extern "C" {
    pub fn nbytesInFile(filename: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn fnbytesInFile(fp: *mut FILE) -> usize;
}
extern "C" {
    pub fn l_binaryCopy(datas: *mut l_uint8, size: usize) -> *mut l_uint8;
}
extern "C" {
    pub fn lept_fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn lept_fclose(fp: *mut FILE) -> l_int32;
}
extern "C" {
    pub fn lept_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lept_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lept_mkdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_rmdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_direxists(dir: *const ::std::os::raw::c_char, pexists: *mut l_int32);
}
extern "C" {
    pub fn lept_rm_match(
        subdir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rm(
        subdir: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rmfile(filepath: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_mv(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_cp(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn splitPathAtDirectory(
        pathname: *const ::std::os::raw::c_char,
        pdir: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn splitPathAtExtension(
        pathname: *const ::std::os::raw::c_char,
        pbasename: *mut *mut ::std::os::raw::c_char,
        pextension: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pathJoin(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn appendSubdirs(
        basedir: *const ::std::os::raw::c_char,
        subdirs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertSepCharsInPath(path: *mut ::std::os::raw::c_char, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn genPathname(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn makeTempDirname(
        result: *mut ::std::os::raw::c_char,
        nbytes: usize,
        subdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn modifyTrailingSlash(
        path: *mut ::std::os::raw::c_char,
        nbytes: usize,
        flag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_makeTempFilename() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn extractNumberFromFilename(
        fname: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSimpleCaptcha(
        pixs: *mut PIX,
        border: l_int32,
        nterms: l_int32,
        seed: l_uint32,
        color: l_uint32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRandomHarmonicWarp(
        pixs: *mut PIX,
        xmag: l_float32,
        ymag: l_float32,
        xfreq: l_float32,
        yfreq: l_float32,
        nx: l_int32,
        ny: l_int32,
        seed: l_uint32,
        grayval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWarpStereoscopic(
        pixs: *mut PIX,
        zbend: l_int32,
        zshiftt: l_int32,
        zshiftb: l_int32,
        ybendt: l_int32,
        ybendb: l_int32,
        redleft: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontal(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalSampled(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalLI(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShear(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearSampled(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearLI(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStereoFromPair(
        pix1: *mut PIX,
        pix2: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn wshedCreate(
        pixs: *mut PIX,
        pixm: *mut PIX,
        mindepth: l_int32,
        debugflag: l_int32,
    ) -> *mut L_WSHED;
}
extern "C" {
    pub fn wshedDestroy(pwshed: *mut *mut L_WSHED);
}
extern "C" {
    pub fn wshedApply(wshed: *mut L_WSHED) -> l_int32;
}
extern "C" {
    pub fn wshedBasins(
        wshed: *mut L_WSHED,
        ppixa: *mut *mut PIXA,
        pnalevels: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn wshedRenderFill(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn wshedRenderColors(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamWebP(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemWebP(filedata: *const l_uint8, filesize: usize) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderWebP(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn readHeaderMemWebP(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteWebP(
        filename: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteStreamWebP(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteMemWebP(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut usize,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixaWriteFiles(
        rootname: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        format: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWrite(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixWriteAutoFormat(filename: *const ::std::os::raw::c_char, pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixWriteStream(fp: *mut FILE, pix: *mut PIX, format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixWriteImpliedFormat(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixChooseOutputFormat(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn getImpliedFileFormat(filename: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixGetAutoFormat(pix: *mut PIX, pformat: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn getFormatExtension(format: l_int32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_fileDisplay(
        fname: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        scale: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplay(pixs: *mut PIX, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixDisplayWithTitle(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        title: *const ::std::os::raw::c_char,
        dispflag: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSaveTiled(
        pixs: *mut PIX,
        pixa: *mut PIXA,
        scalefactor: l_float32,
        newrow: l_int32,
        space: l_int32,
        dp: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSaveTiledOutline(
        pixs: *mut PIX,
        pixa: *mut PIXA,
        scalefactor: l_float32,
        newrow: l_int32,
        space: l_int32,
        linewidth: l_int32,
        dp: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSaveTiledWithText(
        pixs: *mut PIX,
        pixa: *mut PIXA,
        outwidth: l_int32,
        newrow: l_int32,
        space: l_int32,
        linewidth: l_int32,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_chooseDisplayProg(selection: l_int32);
}
extern "C" {
    pub fn pixDisplayWrite(pixs: *mut PIX, reduction: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixDisplayWriteFormat(pixs: *mut PIX, reduction: l_int32, format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixDisplayMultiple(
        res: l_int32,
        scalefactor: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
